<!DOCTYPE HTML>
<html lang="en">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="算法DSA, StanBlog">
    <meta name="description" content="
算法题目已经成为了公司筛人的一种方式，大厂的每一轮面试基本都会有几道算法题，甚至有的公司笔试全部都是算法题。其他题目答的都差不多，那你算法题做不出来，可能就被淘汰了。
所以为啥要刷算法题呢？一方面是帮助你学习和理解算法，但另一方面也是像背">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>


    <title>算法DSA | StanBlog</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="StanBlog" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3592614110969127"
     crossorigin="anonymous"></script>
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">StanBlog</span>
                </a>
            </div>
            
<style>
  #openSearchBtn {
    background: transparent;
    border: none;
    padding: 6px 12px;
    cursor: pointer;
    transition: all 0.3s ease;
  }
#openSearchBtn:hover {
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
}
  #searchIcon {
    color: white;
  }
</style>
<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li>
    <button id="openSearchBtn" type="button" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </button>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">StanBlog</div>
        <div class="logo-desc">
            
            A popular long-form, stick-figure-illustrated blog about almost everything. Material Themes / GitHub Pages 个性化定制的Hexo-Matery主题 
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Stan370/stan370.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Stan370/stan370.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/medias/featureimages/12.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">算法DSA</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E7%BC%96%E7%A8%8B/">
                                <span class="chip bg-color">编程</span>
                            </a>
                        
                            <a href="/tags/%E7%AE%97%E6%B3%95/">
                                <span class="chip bg-color">算法</span>
                            </a>
                        
                            <a href="/tags/CS%E5%9F%BA%E7%A1%80/">
                                <span class="chip bg-color">CS基础</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" class="post-category">
                                计算机科学
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2024-05-24
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>Update Date:&nbsp;&nbsp;
                    2025-03-19
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    15.9k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>Read Times:&nbsp;&nbsp;
                    58 Min
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id=""></h3>
<p>算法题目已经成为了公司筛人的一种方式，大厂的每一轮面试基本都会有几道算法题，甚至有的公司笔试全部都是算法题。其他题目答的都差不多，那你算法题做不出来，可能就被淘汰了。</p>
<p>所以为啥要刷算法题呢？一方面是帮助你学习和理解算法，但另一方面也是像背公式、背八股文一样，增加你面试时碰到原题的概率。像面试无非就那么几个重点：树、动态规划、深度 / 广度优先搜索、链表、数组、排序、栈、队列、哈希、字符串等。你要先完成专项练习中一些简单的题目，理解其背后的算法和数据结构。之后，再举一反三，练习更多相关的题目，当你能做到用同一个算法解决一类共性问题，做到 多题一解 时，才算是真正理解了。</p>
<p>总之,刷算法题是一个漫长而艰辛的过程,但如果坚持下去,一定会收获丰硕的成果。保持积极乐观的心态,循序渐进地提升自己,相信您一定能够成为出色的软件工程师。</p>
<p>伪随机数是用<strong>确定性的算法</strong>计算出来自[0,1]均匀分布的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E6%95%B0/2454368?fromModule=lemma_inlink">随机数</a>序列。并不真正的随机，但具有类似于随机数的统计特征，如均匀性、独立性等。在计算伪随机数时，若使用的初值（种子）不变，那么伪随机数的数序也不变。伪随机数可以用计算机大量生成，在模拟研究中为了提高模拟效率，一般采用伪随机数代替真正的随机数。</p>
<pre><code>    **伪随机数**
</code></pre>
<p><strong>算法与编程竞赛</strong>：大多数算法题和编程竞赛中使用伪随机数生成器就足够了。它们生成速度快，且可以通过设置种子来重现结果，便于调试。</p>
<p><strong>模拟与仿真</strong>：如蒙特卡罗模拟等，需要大量随机数的应用场景，伪随机数的效率和可控性非常重要。</p>
<p><strong>游戏开发</strong>：游戏中的随机事件、物品掉落、敌人生成等，大多数情况下使用伪随机数生成器。</p>
<p><strong>测试与调试</strong>：生成可重复的随机测试数据，便于发现和修复问题。</p>
<pre><code>     **真随机数**
</code></pre>
<p><strong>安全与密码学</strong>：在密码学、加密密钥生成等场景，对随机性的要求极高，真随机数生成器（如硬件随机数生成器）更适用。</p>
<p><strong>科学实验</strong>：某些科学研究和实验需要真正的随机性以避免偏差。</p>
<p><strong>二元关系（Binary Relations）</strong></p>
<p>二元关系是定义在两个集合之间的关系，可以表示成有序对的集合。它在以下方面有重要应用：</p>
<ul>
<li><strong>数据库管理</strong>：二元关系用于定义关系数据库中的表。每个表都是一个二元关系，行表示记录，列表示属性。</li>
<li><strong>图论</strong>：图论中，边是顶点之间的二元关系。它们用于表示网络、通信路径、社交网络等。</li>
<li><strong>函数</strong>：函数是特殊的二元关系，其中每个输入对应一个唯一的输出。函数广泛用于数学建模和计算。</li>
</ul>
<p><strong>偏序（Partial Order）</strong></p>
<p>偏序是一种特殊的二元关系，满足反射性、反对称性和传递性，用于表示元素之间的部分排序关系。它在以下方面有应用：</p>
<ul>
<li><strong>任务调度</strong>：在任务调度和项目管理中，偏序用于表示任务的依赖关系。例如，任务A必须在任务B之前完成。</li>
<li><strong>数据结构</strong>：偏序用于定义数据结构如堆和优先队列。在这些结构中，元素以偏序关系组织。</li>
<li><strong>分类系统</strong>：在分类学中，偏序用于表示分类系统的层级关系。例如，物种分类中的从属关系。</li>
<li><strong>版本控制</strong>：在版本控制系统中，不同版本之间的依赖关系可以用偏序来表示。</li>
</ul>
<p>**全序（Total Order）**全序是一种特殊的偏序，满足每一对元素都是可比较的，即任何两个元素之间都有确定的顺序关系。全序在以下方面有应用：</p>
<ul>
<li><strong>排序算法</strong>：全序用于定义排序算法的排序关系。常见的排序算法如快速排序、归并排序都依赖全序关系来确定元素的排列顺序。</li>
<li><strong>搜索算法</strong>：二分搜索等高效搜索算法依赖于元素的全序性。</li>
<li><strong>经济学</strong>：在经济学中，全序用于表示消费者偏好和商品价格等，使得商品和服务可以按优劣排序。</li>
<li><strong>决策理论</strong>：全序用于决策理论中的选择偏好，帮助决策者在不同选项之间进行比较和选择。</li>
</ul>
<p>贪心选择的一般特征：贪心选择性质和最优子结构性质。</p>
<p>贪心算法和动态规划算法都要求问题具有最优子结构性质，这是两类算法的一个共同点。大多数时候，能用贪心算法求解的问题，都可以用动态规划算法求解。但是能用动态规划求解的，不一定能用贪心算法进行求解。</p>
<p>找到最优子结构 =&gt; 动态规划解<strong>最值问题</strong>，状态转移方程</p>
<ol>
<li>最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</li>
<li>无后效性。即子问题的解一旦确定，就不再改变，<strong>不受在这之后、包含它的更大的问题的求解决策影响</strong>。<strong>解的计算不依赖于问题的后续阶段，只依赖于当前阶段的状态</strong>。这使得我们可以独立地解决子问题，而不必关心它们如何被组合起来形成更大的问题的解决方案。</li>
<li>子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。</li>
</ol>
<h2 id="Dynamic-Programing">Dynamic Programing</h2>
<p>动态规划（Dynamic Programming，简称DP）是一种求解最优化问题的方法。它通过将问题分解成更小的子问题，利用子问题的解来构造原问题的解。动态规划的核心思想是避免重复计算，通过存储子问题的结果来提高效率。下面是动态规划在多个领域的应用和示例代码。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/tXLS3i/">https://leetcode.cn/circle/discuss/tXLS3i/</a></p>
<p><strong>动态规划（入门/背包/状态机/划分/区间/状压/数位/树形/数据结构优化）</strong></p>
<p><strong>记忆化搜索</strong></p>
<p>在求解动态规划的问题时，记忆化搜索和递推，都确保了同一状态至多只被求解一次。而它们实现这一点的方式则略有不同：递推通过设置明确的访问顺序来避免重复访问，记忆化搜索虽然没有明确规定访问顺序，但通过给已经访问过的状态打标记的方式，也达到了同样的目的。</p>
<p>与递推相比，记忆化搜索因为不用明确规定访问顺序，在实现难度上有时低于递推，且能比较方便地处理边界情况，这是记忆化搜索的一大优势。但与此同时，记忆化搜索难以使用滚动数组等优化，且由于存在递归，运行效率会低于递推。因此应该视题目选择更适合的实现方式。</p>
<ol>
<li>把这道题的 dp 状态和方程写出来</li>
<li>根据它们写出 dfs 函数</li>
<li>添加记忆化数组</li>
</ol>
<p><strong>状态压缩 DP（状压 DP）</strong></p>
<p>§9.1 排列型 ① 相邻无关</p>
<p>从记忆化搜索到递推，从集合论到位运算，这里总结了常见的位运算技巧分类。</p>
<ul>
<li>暴力做法是枚举所有排列，对每个排列计算和题目有关的值，时间复杂度（通常来说）是 O(n⋅n!)。这种方法可以解决 n≤10 的问题。</li>
</ul>
<p><strong>状态压缩</strong></p>
<blockquote>
<p>状态压缩 DP：简称为「状压 DP」，是一种应用在「小规模数据,  n≤20」的数组 / 字符串上，结合「二进制」的性质来进行状态定义与状态转移的动态规划方法。和「二进制枚举子集算法」一样，我们通过一个「 n 位长度的二进制数」来表示「由 n 个物品所组成的集合中所有物品的选择状态」。状压 DP 可以把时间复杂度（通常来说）优化至 O(n⋅2^n)。   一维状态是集合，对状态进行操作或者状态之间进行转移，也就是要对集合进行操作。 因为我们使用二进制数来定义集合状态，所以对集合进行操作，就是对二进制数进行位运算操作。</p>
</blockquote>
<p>使用一个 int 类型的变量代替 visited数组</p>
<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/ea503cf6-9325-47ab-9fb3-3e33e40583ef/d1ef25f1-861d-4b22-af76-94adb2b544f9/Untitled.png" alt="Untitled"></p>
<p>状压 DP 通常有两种定义方式：</p>
<ol>
<li>定义 f[S] 表示已经排列好的元素（下标）集合为 S 时，和题目有关的最优值。通过枚举当前位置要填的元素（下标）来转移。</li>
<li>定义 f[S] 表示可以选的元素（下标）集合为 S 时，和题目有关的最优值。通过枚举当前位置要填的元素（下标）来转移。</li>
</ol>
<p>注：部分题目由于爆搜+剪枝也能过，难度分仅供参考。</p>
<ul>
<li>优美的排列</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 二进制数和集合的一一对应关系。</span><br><span class="line">如集合s=<span class="number">9</span>时，其二进制数为<span class="number">10001</span>，对应<span class="number">2</span>^<span class="number">4</span>位、<span class="number">2</span>^<span class="number">0</span>位为<span class="number">1</span>，可以表示集合中包含元素<span class="number">0</span> <span class="number">4</span>。</span><br><span class="line">对于本题来说，下标是从<span class="number">1</span>开始的，所以将<span class="number">2</span>^<span class="number">0</span>位为<span class="number">1</span>视为表示<span class="number">1</span>在集合内，即灵神说的本题二进制的最低位表示 <span class="number">1</span>。</span><br><span class="line">s.<span class="title function_">bit_count</span>()统计了s中有多少个<span class="number">1</span>，即代表集合中有多少个元素。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 判断元素i是否在集合s内：</span><br><span class="line">(s &gt;&gt; i) &amp; <span class="number">1</span></span><br><span class="line">如s的二进制为:<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>，i=<span class="number">4</span>，判断i是否在s内即判断s的<span class="number">2</span>^<span class="number">4</span>位是否为<span class="number">1</span>，只需把s右移<span class="number">4</span>位后和<span class="number">1</span>相与。 </span><br><span class="line">本题的下标是从<span class="number">1</span>开始的，要减<span class="number">1</span>之后才能和二进制中的位相对应，所以灵神用的 (s &gt;&gt; (j-<span class="number">1</span>) &amp; <span class="number">1</span>)，</span><br><span class="line">这个表达式为<span class="number">0</span>表示元素j不在集合s中。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 向集合s中添加元素i。</span><br><span class="line">s | (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line"><span class="number">1</span>&lt;&lt;i是设置<span class="number">2</span>^i位为<span class="number">1</span>，s|(<span class="number">1</span>&lt;&lt;i)即设置s的<span class="number">2</span>^i位等于<span class="number">1</span>。灵神的<span class="title function_">dfs</span>(s | (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)))即向集合中添加元素j。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> u表示全集。</span><br><span class="line">即从<span class="number">1</span>到n所有数都选上的集合。</span><br></pre></td></tr></table></figure>
<p>定义 <em>dfs</em>(<em>S</em>,<em>i</em>) 表示在可以选的下标集合为 <em>S</em>，上一个选的数的下标是 <em>i</em> 时，可以构造出多少个特别排列。</p>
<ul>
<li>特别的排列：给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，它包含 <code>n</code> 个 <strong>互不相同</strong> 的正整数。如果 <code>nums</code> 的一个排列满足以下条件，我们称它是一个特别的排列：对于 <code>0 &lt;= i &lt; n - 1</code> 的下标 <code>i</code> ，要么 <code>nums[i] % nums[i+1] == 0</code> ，要么 <code>nums[i+1] % nums[i] == 0</code> 。</li>
</ul>
<p><strong>栈是递归的底层实现，</strong> 我们用栈实现队列，用队列实现栈来掌握的栈与队列的基本操作。</p>
<p>接着，通过括号匹配问题、字符串去重问题、删除字串问题，逆波兰表达式问题来系统讲解了栈在系统中的应用，以及使用技巧。</p>
<p>通过求滑动窗口最大值，以及前K个高频元素介绍了两种队列：单调队列和优先级队列，这是特殊场景解决问题的利器，是一定要掌握的。</p>
<blockquote>
<p>正常循环的情况下，数组的滚动（游标移动）是向后的，引入栈的时候，<strong>则可以有了向前滚动的机会（有了一定的反悔的机会），然后这样子就能够解决一些局部的问题</strong>（比如说，寻找相邻的大的数字）。由于栈还可以对于没有价值（已经发现了大的数字）的东西删除，这样子的遗忘功能，<strong>简化了搜索空间，问题空间。</strong></p>
</blockquote>
<p>当一个算法完全不进行<strong>多余</strong>的运算，那么它是一个时间复杂度最低的算法。但我们往往会对一些结果进行<strong>重复</strong>的计算，那么栈的引入就是为了解决这样的问题，栈<strong>存储</strong>了一些<strong>重要</strong>的运算结果，用于和接下来的元素进行<strong>比较</strong>。</p>
<p><strong>单调队列</strong><br>
可以查询区间最值（不能维护区间k大，因为队列中很有可能没有k个元 素）<br>
优化DP 	优化动态规划方面问题的一种特殊数据结构，且多数情况是与定长连续子区间问题相关联。<br>
<strong>单调栈       对于某个元素i：</strong></p>
<p>左边区间第一个比它小的数，第一个比它大的数<br>
确定这个元素是否是区间最值<br>
右边区间第一个大于它的值<br>
到 右边区间第一个大于它的值 的距离<br>
确定以该元素为最值的最长区间</p>
<p><strong>单调递增栈</strong>：只有比栈顶元素小的元素才能直接进栈，否则需要先将栈中比当前元素小的元素出栈，再将当前元素入栈。这样就保证了：栈中保留的都是比当前入栈元素大的值，并且从栈顶到栈底的元素值是单调递增的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">monotoneIncreasingStack</span>(nums):</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="attr">nums</span>:</span><br><span class="line">        <span class="keyword">while</span> stack and num &gt;= stack[-<span class="number">1</span>]:</span><br><span class="line">            stack.<span class="title function_">pop</span>()</span><br><span class="line">        stack.<span class="title function_">append</span>(num)</span><br></pre></td></tr></table></figure>
<p>2.1 寻找左侧第一个比当前元素大的元素 <a target="_blank" rel="noopener" href="https://algo.itcharge.cn/03.Stack/02.Monotone-Stack/01.Monotone-Stack/#21-%e5%af%bb%e6%89%be%e5%b7%a6%e4%be%a7%e7%ac%ac%e4%b8%80%e4%b8%aa%e6%af%94%e5%bd%93%e5%89%8d%e5%85%83%e7%b4%a0%e5%a4%a7%e7%9a%84%e5%85%83%e7%b4%a0">#</a></p>
<p>从左到右遍历元素，构造单调递增栈（从栈顶到栈底递增）：</p>
<ul>
<li>一个元素左侧第一个比它大的元素就是将其「插入单调递增栈」时的栈顶元素。</li>
<li>如果插入时的栈为空，则说明左侧不存在比当前元素大的元素。</li>
</ul>
<p>单调队列实际上是单调栈的的升级版。单调栈只支持访问尾部，而单调队列两端都可以。</p>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97&amp;spm=1001.2101.3001.7020">单调队列</a>是指：队列中元素之间的关系具有单调性，而且，队首和队尾都可以进行出队操作，只有队尾可以进行入队操作。</p>
<h3 id="307-区域和检索-数组可修改"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/"><strong>307. 区域和检索 - 数组可修改</strong></a></h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/description/">https://leetcode.cn/problems/range-sum-query-mutable/description/</a></p>
<p>线段树是算法竞赛中常用的用来维护 <strong>区间信息</strong> 的数据结构。</p>
<p>线段树可以在O(logn)的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。</p>
<p>如果要求修改区间 [l,r]，把所有包含在区间 [l,r] 中的节点都遍历一次、修改一次，时间复杂度无法承受。我们这里要引入一个叫做 「懒惰标记」 的东西。 懒惰标记，简单来说，就是通过延迟对节点信息的更改，从而减少可能不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点对应的区间在某一次操作中被更改，但不更新该节点的子节点的信息。实质性的修改则在下一次访问带有标记的节点时才进行。</p>
<p><strong>事实上，树状数组能解决的问题是线段树能解决的问题的子集</strong></p>
<p>树状数组（Fenwick Tree，或称 Binary Indexed Tree，BIT）是一种数据结构，支持快速的前缀和计算和单点更新操作，常用于处理数列和二维矩阵中的区间查询和更新问题。因为我们总能将[1,n]拆分成不多于logn段区间，来快速求解信息，所以树状数组的时间复杂度是 O(log⁡n)，适合处理动态数据。</p>
<p>树状数组利用树的结构来存储数列的部分和，使得我们可以快速进行前缀和查询和单点更新。树状数组中的每个节点存储一部分区间的和，节点的索引使用二进制数的最低位1来确定。</p>
<ul>
<li>树状数组中，每个索引 <code>i</code> 存储的值代表从 <code>i</code> 到 <code>i - (i &amp; -i) + 1</code> 之间元素的和。</li>
</ul>
<p>树状数组的索引通过**最低有效位（Least Significant Bit, LSB）**进行操作，tree索引从1开始</p>
<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/ea503cf6-9325-47ab-9fb3-3e33e40583ef/5f9cae3c-e65a-47f2-b6a9-7098e587d961/Untitled.png" alt="Untitled"></p>
<p><strong>单点更新</strong>：更新数组中某个位置的值，同时更新与该位置相关的树状数组节点。</p>
<p><strong>前缀和查询</strong>：查询数组中前 i 个元素的和。</p>
<p><a href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7</a></p>
<h2 id="滑动窗口"><strong>滑动窗口</strong></h2>
<p>3个核心问题</p>
<p><strong>1. 什么时候应该扩大窗口？</strong></p>
<ul>
<li><strong>目标：</strong> 我们的目标是找到满足特定条件的<strong>最优窗口</strong>（可能是最大/最小长度，或者包含特定元素组合等）。</li>
<li><strong>扩大时机：</strong> 当<strong>当前窗口还不满足条件</strong>时，我们需要<strong>扩大窗口</strong>来探索更多可能性。这意味着将窗口的右边界向右移动，纳入更多元素。</li>
</ul>
<p><strong>2. 什么时候应该缩小窗口？</strong></p>
<ul>
<li><strong>目标：</strong> 一旦窗口<strong>满足条件</strong>，我们就要考虑是否可以<strong>缩小窗口</strong>，以便找到更优解或排除无效解。</li>
<li><strong>缩小时机：</strong>
<ul>
<li><strong>窗口不再满足条件:</strong> 当移动左边界导致窗口不再满足条件时，我们需要立即停止缩小，并将左边界回退一步。</li>
<li><strong>优化目标:</strong> 即使窗口满足条件，我们也可能需要缩小窗口来寻找更优解。例如，寻找最小窗口时，我们会尝试缩小窗口，看看是否存在更小的满足条件的窗口。</li>
</ul>
</li>
</ul>
<p><strong>3. 什么时候应该更新答案？</strong></p>
<ol>
<li>寻找最长解时，我们通常在扩大窗口（移动右指针）后更新答案。寻找最短解时，我们通常在缩小窗口（移动左指针）前更新答案。</li>
<li>示例问题：
<ul>
<li>最长问题：找出最长的无重复字符子串。</li>
<li>最短问题：找出包含所有目标字符的最短子串。</li>
</ul>
</li>
</ol>
<p>滑动窗口指的是这样一类问题的求解方法，在数组上通过双指针同向移动而解决的一类问题。将嵌套的循环问题，转换为单循环问题，降低<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A620247024%7D">时间复杂度</a>为O（n）。</p>
<ol>
<li>内层循环 <strong><code>for window[c]</code></strong> 用来缩小窗口。虽然它看起来是嵌套在外层循环中的，但实际上每个字符只会被从窗口中移出一次。也就是说，左指针 <strong><code>left</code></strong> 最多移动 n 次。</li>
</ol>
<p>：寻找满足xx最长子串/子数组/子序列</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/53295652-bbef-43ae-a3ef-cb7a6b304b5b/Untitled.png" alt="Untitled"></p>
<p>1.当不满足条件时，拓展右边界，当满足条件时，缩短左边界，最后得到一个解并暂存<br>
2.循环第一步，又得到一个解，将其与第一个解相对比，得到最优解并暂存，以此类推。</p>
<p><strong>最长有效括号</strong>可以用滑动窗口解决吗？</p>
<p>“最长有效括号” 问题，经典的解法是用栈或动态规划，但用滑动窗口并不能很好地解决。</p>
<p><strong>为什么滑动窗口不适合？</strong></p>
<ol>
<li><strong>滑动窗口的本质是寻找满足条件的连续子区间。</strong> 在“最长有效括号”问题中，有效括号的子串并不一定连续。例如：“()(())” 中，最长有效括号是 “()(())”，它包含了两个独立的有效括号子串。</li>
<li><strong>滑动窗口难以处理括号的嵌套关系。</strong> 滑动窗口通常在满足某个条件时才缩小窗口，而判断括号的有效性需要考虑括号的配对关系，这在滑动窗口中难以实现。</li>
</ol>
<p>solution ： 1.dp 2.栈  3.双向扫描</p>
<p>栈写法：思路 我们需要储存最后一个不匹配的右括号下标，所以初始化stack元素为-1， 利用栈来保持对括号匹配的追踪，来处理嵌套和不连续的括号子串</p>
<p>当遇到右括号时a) 如果栈不为空：</p>
<ul>
<li>这意味着我们成功匹配了一对括号。</li>
<li>现在栈顶元素代表的是当前有效括号子串之前的位置。</li>
<li>因此，当前下标减去栈顶元素就是当前有效括号子串的长度。</li>
</ul>
<p>b) 如果栈为空：</p>
<ul>
<li>这意味着我们遇到了一个多余的右括号，它不能与任何左括号匹配。</li>
<li>在这种情况下，我们将当前下标压入栈中，作为新的起始点。</li>
<li>这个操作相当于重置了计数，因为之前的所有括号都不再可能形成有效的括号串。</li>
</ul>
<h3 id="347-前-K-个高频元素"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h3>
<p>最大（小）堆是指在树中，存在一个结点而且该结点有儿子结点，该结点的data域值都不小于（大于）其儿子结点的data域值，并且它是一个完全二叉树。</p>
<p>对于 topk 问题：最大堆求topk小，最小堆求 topk 大。</p>
<p>topk小：构建一个 k 个数的最大堆，当<strong>读取的数小于根节点时</strong>，替换根节点，重新塑造最大堆 topk大：构建一个 k 个数的最小堆，当读取的数<strong>大于</strong>根节点时，替换根节点，重新塑造最小堆 eg. leetcode 215</p>
<p>借助 哈希表 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率 维护一个元素数目为 k的最小堆why？</p>
<p>每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较 如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中 最终，堆中的 kk 个元素即为前 kk 个高频元素</p>
<p>是使用小顶堆呢，还是大顶堆？</p>
<p>有的同学一想，题目要求前 K 个高频元素，那么果断用大顶堆啊。</p>
<p>那么问题来了，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。</p>
<p><strong>所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">**原地</a>修改输入数组**</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/A233666/article/details/113956814">https://blog.csdn.net/A233666/article/details/113956814</a></p>
<p>如果不是原地修改的话，我们直接 new 一个 <code>int[]</code> 数组，把去重之后的元素放进这个新数组中，然后返回这个新数组即可。</p>
<p>但是原地删除，不允许我们 new 新数组，只能在原数组上操作，然后返回一个长度，这样就可以通过返回的长度和原始数组得到我们去重后的元素有哪些了。</p>
<p>这种需求在数组相关的算法题中时非常常见的，<strong>通用解法就是我们前文 <a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7.html">双指针技巧</a> 中的快慢指针技巧</strong>。</p>
<p>我们让慢指针 <code>slow</code> 走在后面，快指针 <code>fast</code> 走在前面探路，找到一个不重复的元素就告诉 <code>slow</code> 并让 <code>slow</code> 前进一步。这样当 <code>fast</code> 指针遍历完整个数组 <code>nums</code> 后，<strong><code>nums[0..slow]</code> 就是不重复元素</strong>。</p>
<p><strong>最大化最小值/ 最小化最大值问题</strong><br>
基本题型: 给定n个整数序列，将其划分为m个连续子序列，求这m个子序列的和的最大化最小值 或者最小化最大值问题。 Leetcode 410<br>
解题思路: <strong>二分法</strong></p>
<p>二分查找细节<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/">https://leetcode.cn/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/</a></p>
<p>while 中是 &lt; 还是 &lt;=?</p>
<p>答：left==right时是否需要终止循环，是否找到</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 定义target在左闭右开的区间里，即：[left, right)        while (left &lt; right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//二分查找</span><br><span class="line">int binary_search(int[] nums, int target) {</span><br><span class="line">    int left = 0, right = nums.length - 1;</span><br><span class="line">    while(left &lt;= right) {</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] &lt; target) {</span><br><span class="line">            left = mid + 1;</span><br><span class="line">        } else if (nums[mid] &gt; target) {</span><br><span class="line">            right = mid - 1;</span><br><span class="line">        } else if(nums[mid] == target) {</span><br><span class="line">            // 直接返回</span><br><span class="line">            return mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    // 直接返回</span><br><span class="line">    return -1;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="组合数学">组合数学</h2>
<p>Catalan 数列</p>
<p><a href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7</a></p>
<p>可以应用于以下问题：</p>
<ol>
<li>
<p>有 2n个人排成一行进入剧场。入场费 5 元。其中只有 n个人有一张 5 元钞票，另外 n 人只有 10 元钞票，剧院无其它钞票，问有多少种方法使得只要有 10 元的人买票，售票处就有 5 元的钞票找零？</p>
<p><a href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7</a></p>
<p><a href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7</a></p>
<p><a href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7</a></p>
</li>
<li>
<p>一位大城市的律师在她住所以北 n 个街区和以东 n 个街区处工作。每天她走 2n 个街区去上班。如果她从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？</p>
<p><a href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7</a></p>
<p><a href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7</a></p>
<p><a href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7</a></p>
</li>
<li>
<p>在圆上选择 2n 个点，将这些点成对连接起来使得所得到的  条线段不相交的方法数？</p>
<p><a href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7</a></p>
<p><a href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7</a></p>
</li>
<li>
<p>一个栈（无穷大）的进栈序列为1,2,3…n  有多少个不同的出栈序列？</p>
<p><a href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7</a></p>
</li>
<li>
<p>n个结点可构造多少个不同的二叉树？</p>
<p><a href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7</a></p>
</li>
</ol>
<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/ea503cf6-9325-47ab-9fb3-3e33e40583ef/ac8a6425-a1eb-4273-a125-106d72d07352/Untitled.png" alt="Untitled"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/interleaving-string/">**97. 交错字符串</a>**</p>
<p>给定三个字符串 <code>s1</code>、<code>s2</code>、<code>s3</code>，请你帮忙验证 <code>s3</code> 是否是由 <code>s1</code> 和 <code>s2</code> **<strong>交错</strong> 组成的。</p>
<p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交错</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> 子字符串：</p>
<ul>
<li><code>s = s1 + s2 + ... + sn</code></li>
<li><code>t = t1 + t2 + ... + tm</code></li>
<li><code>|n - m| &lt;= 1</code></li>
<li><strong>交错</strong> 是 <code>s1 + t1 + s2 + t2 + s3 + t3 + ...</code> 或者 <code>t1 + s1 + t2 + s2 + t3 + s3 + ...</code></li>
</ul>
<p>怎么想到DP解法而不是双指针 有感：</p>
<p><strong>斐波那契数列</strong>：</p>
<ul>
<li>DFS解法是递归地计算第 n 个斐波那契数。</li>
<li>该问题可以转换为DP，通过存储每个子问题的解来减少重复计算，例如使用数组或哈希表来存储已计算的结果。</li>
</ul>
<p><strong>NP-完全问题</strong>：</p>
<ul>
<li>一些问题，如旅行商问题（TSP）等属于NP-完全问题，DFS可能可以用来找到解，但难以以多项式时间转换为DP。</li>
</ul>
<p>大部分能暴力递归式（dfs）解决的问题就在形式上是dp的了，你只要把暴力递归式的输入参数当成状态来看待，真正的难点在于把暴力递归的状态进行压缩合并变到多项式大小的状态集合，所以不是你意识不到他是不是dp问题，而是你没有足够的经验和思路去把一个算法最简单的状态集合设计出来. When doing leetcode, using dp的难点是你就算知道了用dp，也可能想不出状态转移方程<br>
有时即使你意识到问题可以用DP解决，也可能遇到难以找到状态转移方程的困难。这可能需要更多的经验、练习和对问题的探索，以便设计出最优的状态集合和转移方程。</p>
<p>• 动态规划可以被看作是优化后的暴力递归版本。它通常通过存储子问题的解并避免重复计算来提高效率，从而将指数级的时间复杂度降低为多项式级别。</p>
<p>字符串的题 dfs 可作为一种解法。 <strong>遇到字符串(字串，子数组，子序列)题，先想DP</strong>.…</p>
<h3 id="Graph">Graph</h3>
<p>Floyd 算法       是用来求任意两个结点之间的最短路的。</p>
<p>复杂度比较高，但是常数小，容易实现（只有三个 <code>for</code>）。</p>
<p>适用于任何图，不管有向无向，边权正负，但是最短路必须存在。（不能有个负环）</p>
<p>Dijkstra 算法的基本思路。它使用优先队列来管理节点，不断选择距离源节点最近的节点，并更新与其相邻节点的距离，直到所有节点都被访问过或者最短路径已知。</p>
<p><strong>一个连通图的生成树是一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的n-1条边。</strong></p>
<p><strong>生成树</strong>是对应连通图来说，而生成森林是对应非连通图来说的。如果一个图有n个顶点和小于n-1条边，则是非连通图；如果它多于n-1条边，则一定有环，但有n-1条边的图不一定是生成树。</p>
<p>并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要查找一个元素在哪个集合中。</p>
<p><strong>并查集应用</strong></p>
<ul>
<li><strong>求连通分量</strong>：依次对每个边的两个顶点进行并查集合并，可以使得每个连通分量的root相同，从而得出每个连通分量。</li>
<li><strong>查找环</strong>：合并过程中，如果发现一条边的两个顶点已经合并过，说明这两个顶点之前已经通过其他路径合并，再加上这条边，图中就出现了环。</li>
<li><strong>求最小生成树</strong>：贪心思想，从小到大排序所有边，使用并查集依次合并，并跳过形成环的边，即可得到最小生成树。</li>
</ul>
<p>拓扑排序</p>
<p>使用Kahn算法，实际上就是一种BFS算法。在解决有向无环图的时候比较有用。</p>
<p>● 计算入度，将所有入度为0的顶点加入队列</p>
<p>● 取出队列顶点，更新入度，重复操作</p>
<h2 id="回溯法-剪枝-DFS">回溯法+剪枝/ DFS</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">带访问标记</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(graph [][]<span class="type">int</span>, visited []<span class="type">bool</span>, node <span class="type">int</span>)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> visited[node] {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    visited[node] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理当前节点</span></span><br><span class="line">    fmt.Println(node)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> _, neighbor := <span class="keyword">range</span> graph[node] {</span><br><span class="line">        dfs(graph, visited, neighbor)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">回溯算法模板（适用于排列、组合、子集等问题）：</span><br><span class="line"></span><br><span class="line">func backtrack(choices []int, path []int, used []bool, result *[][]int) {</span><br><span class="line">    if /* 满足条件 */ {</span><br><span class="line">        *result = append(*result, append([]int{}, path...))</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line">    for i, choice := range choices {</span><br><span class="line">        if used[i] {</span><br><span class="line">            continue</span><br><span class="line">        }</span><br><span class="line">        path = append(path, choice)   //做选择</span><br><span class="line">        used[i] = true</span><br><span class="line">        backtrack(choices, path, used, result)</span><br><span class="line">  </span><br><span class="line">        // 撤销选择（回溯）</span><br><span class="line">        path = path[:len(path)-1]</span><br><span class="line">        used[i] = false</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这一类问题都需要先画出树形图，然后编码实现。</p>
<p>编码通过 深度优先遍历 实现，使用一个列表，在 深度优先遍历 变化的过程中，遍历所有可能的列表并判断当前列表是否符合题目的要求</p>
<p>如果题目要求，结果集不计算顺序，此时需要按顺序搜索，才能做到不重不漏。「力扣」第 47 题（ 全排列 II ）、「力扣」第 15 题（ 三数之和 ）也使用了类似的思想，使得结果集没有重复。</p>
<p>Recursive algorithms can be both <strong>in-place and not-in-place</strong>, depending on how they are implemented. In computer science, an “in-place” algorithm is one that uses <strong>a constant amount of extra memory</strong> or auxiliary data structures to perform its operations, regardless of the size of the input data. On the other hand, a “not-in-place” algorithm uses additional memory that grows with the input size. 因此，虽然精确的空间复杂度分析（O(1)、O(n) 等）对于理论讨论和比较很有用，但现实世界的考虑通常会导致对算法的内存使用情况进行更细致的评估。目标是在空间效率和算法简单性之间取得平衡，使代码更容易理解和维护，同时仍然实现可接受的性能。</p>
<h2 id="树和二叉树">树和二叉树</h2>
<p><strong>两种递归本质</strong>的理解也殊途同归一下：</p>
<p>自顶向下的递归和自底向上的递归是两种不同的思考方式，它们在设计和实现递归算法时各有优缺点。自顶向下的方法通常更直观（n！），更容易理解，因为它与“分而治之”的策略相似。然而，对于非常大的问题，它可能会导致大量的重复计算，因为每个子问题都可能需要被多次解决。</p>
<p>可以用 <strong>记忆化搜索（Memoization）</strong>：通过记录已经计算过的子问题的结果，避免重复计算，从而提升效率。</p>
<p>自底向上的方法则从基本情况出发（Fibonacci），通过组合基本情况来解决更复杂的问题，这有助于减少重复计算。然而，它可能需要更多的初始步骤来确定问题的边界和基本情况。了解这两种方法可以帮助我们根据具体问题选择合适的实现方式。</p>
<ol>
<li>树本身是一种简单化的图</li>
<li>自顶向下/自下向上本质上对应着dfs（深度优先）/bfs（广度优先）</li>
</ol>
<ul>
<li><strong>先序遍历（前序遍历）</strong>：先访问当前节点，然后递归地访问左子树和右子树。它是DFS的一种体现，常用于创建复制树、输出树结构等。</li>
<li><strong>中序遍历</strong>：先访问左子树，然后访问当前节点，最后访问右子树。兼具 DFS 和 BFS 的思想，在二叉搜索树中，它能得到有序的结果（类似 BFS 的层次感），<strong>但遍历过程仍然是深度优先的</strong>。</li>
<li><strong>后序遍历</strong>：先递归地访问左子树和右子树，然后访问节点本身。这不完全对应BFS。后序遍历常用于先处理子节点再处理父节点的情形，如树形DP、计算树的高度等，其实更倾向于DFS的一种应用。</li>
</ul>
<p><strong>快速排序与二叉树的前序遍历类比：</strong></p>
<p>快速排序的过程可以类比为二叉树的前序遍历，因为快速排序通过选取一个基准值（pivot），将数组分为两部分，并递归地对子数组进行排序。这个过程可以类比为前序遍历，先处理当前节点（即当前的基准值），然后递归地处理左右子树（较小和较大的元素）。</p>
<p><strong>归并排序与二叉树的后序遍历类比：</strong></p>
<p>归并排序的过程可以类比为二叉树的后序遍历，因为归并排序将数组递归地分割为更小的子数组，然后合并这些子数组。这个过程类似于后序遍历，先递归地处理左右子树（将数组分割为更小的部分），然后在递归回溯时进行合并操作（将两个有序的子数组合并为一个有序的数组）。</p>
<p>虽然这种类比有助于理解快速排序和归并排序的工作原理</p>
<p>动归/DFS/回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同：</p>
<ul>
<li><strong>动态规划</strong>：动态规划是一种将问题分解为子问题，并以自底向上的方式解决的方法。每个子问题的解决方案被记录下来，以避免重复计算。你可以将动态规划问题视为填充一张二维表格，其中每个格子代表一个子问题的解，从而形成一种树状的结构。这与二叉树的概念有些类似。</li>
<li><strong>回溯</strong>：<strong>回溯是一种深度优先的搜索方法</strong>，通常用于解决排列、组合、子集等问题。你可以将回溯过程看作在一个决策树上的遍历，每个节点代表一个选择，通过遍历树上的路径来寻找解。你的理解关于回溯关注于节点间的「树枝」是正确的。</li>
</ul>
<p>回溯算法是系统地搜索问题的解的方法。</p>
<p>某个问题的所有可能解的称为问题的解空间，若解空间是有限的，则可将解空间映射成树结构。</p>
<p>任何解空间可以映射成树结构的问题，都可以使用回溯法。</p>
<p>回溯法是能够在树结构里搜索到通往特定终点的一条或者多条特定路径。</p>
<p>回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试，从而搜索到抵达特定终点的一条或者多条特定路径。</p>
<p>值得注意，回溯法以深度优先搜索的方式搜索解空间，并且在搜索过程中用<strong>剪枝</strong>函数避免无效搜索。</p>
<ul>
<li><strong>DFS</strong>：深度优先搜索是一种遍历图或树的方法。它从一个起始节点出发，沿着一个路径一直向下遍历，直到无法继续为止，然后回溯并探索其他分支。你的理解关于DFS关注于单个「节点」也是正确的。</li>
</ul>
<p>如上面所言，深度优先搜索是特定于图结构的一种搜索算法，回溯算法是特定于树结构的搜索算法。</p>
<p>遍历</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c57a2004-37c9-4653-9daa-ac2816fc2790/Untitled.png" alt="Untitled"></p>
<p>中序遍历：递归，栈，移动右子树使用pre指针遍历</p>
<p>Morris 遍历是一种不使用递归和栈，而是利用线索二叉树（Threaded Binary Tree）的思想来实现二叉树的遍历，包括中序遍历、前序遍历和后序遍历。Morris 遍历的优点在于它使用的**空间复杂度是 O(1)，**并且不会破坏原来的树结构。（leetcode99</p>
<p>Morris 遍历算法的关键在于如何建立临时的线索连接，从而在遍历过程中完成左右子树节点的跳转，而不需要额外的空间。</p>
<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/ea503cf6-9325-47ab-9fb3-3e33e40583ef/77aacc26-b749-466c-a7b1-16ce355ca216/Untitled.png" alt="Untitled"></p>
<p>这个算法的核心思想是在遍历过程中修改树的结构，将节点的右子树指向后继节点，然后再恢复树的结构，以便能够顺序遍历节点。这种方法在空间效率上具有显著优势，但需要小心处理节点的指针，以避免陷入无限循环。</p>
<h3 id="BST-AVL">BST AVL</h3>
<p>BST二叉查找树（排序树），若它的左子树不空，则左子树上所有的结点的值均不大于它根结点的值；　　若它的左子树不空，则左子树上所有的结点的值均不小于它根结点的值；</p>
<p><strong>最</strong>重要的性质是：<strong>二叉搜索树的中序遍历是有序的</strong></p>
<p>当节点数目一定，保持树的左右两端保持平衡，树的查找效率最高。</p>
<p><strong>这种左右子树的高度相差不超过 1 的树为平衡二叉树。</strong></p>
<p>性质：</p>
<ol>
<li>可以是空树。</li>
<li>假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，高度之差的绝对值不超过 1 。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。</li>
</ol>
<p>以递归解决二叉树这种对称数据结构的策略，称为对称性递归。可以用**对称性递归解决的二叉树问题大多是判断性问题(bool类型函数),**这一类问题又可以分为以下两类：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/">https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/</a><br>
1、不需要构造辅助函数。这一类题目有两种情况：第一种是单树问题，且不需要用到子树的某一部分(比如根节点左子树的右子树)，只要利用根节点左右子树的对称性即可进行递归。第二种是双树问题，即本身题目要求比较两棵树，那么不需要构造新函数。该类型题目如下：</p>
<ol>
<li>相同的树 翻转二叉树</li>
<li>二叉树的最大深度</li>
<li>平衡二叉树</li>
<li>二叉树的直径</li>
<li>合并二叉树 另一个树的子树 单值二叉树</li>
</ol>
<p>2、需要构造辅助函数。这类题目通常只用根节点子树对称性无法完全解决问题，必须要用到子树的某一部分进行递归，即要调用辅助函数比较两个部分子树。形式上主函数参数列表只有一个根节点，辅助函数参数列表有两个节点。该类型题目如下：</p>
<ol>
<li>对称二叉树 剑指 Offer 26. 树的子结构</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a>，并注意与这道题的区别：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a>。与字符串对比的话，子树就相当于字符串的子串（要求连续），树的子结构就相当于字符串的子序列（不要求连续）</p>
<p>为什么还需要非线性结构呢？ 答案是为了高效地兼顾静态操作和动态操作，<strong>我们一般使用树去管理需要大量动态操作的数据</strong></p>
<p>堆排序的基本思想是先将待排序的序列构建成一个堆，然后依次从堆顶取出最值（最大值或最小值），将其与堆的最后一个元素交换，并将堆的大小减一，然后再通过一系列操作使得剩余的元素重新构建成一个堆。重复执行此过程，直到堆为空，从而得到一个有序的序列。</p>
<p>堆排序的主要步骤如下：</p>
<ol>
<li>构建初始堆：将待排序序列构建成一个初始堆，即满足堆的特性。</li>
<li>交换和调整：将堆顶元素与堆的最后一个元素交换位置，并将堆的大小减一。然后通过向下调整（或向上调整）操作，使剩余元素重新构建成一个堆。</li>
<li>重复执行步骤2，直到堆为空。</li>
</ol>
<p>由于<strong>完全二叉树</strong>的性质，堆排序可以高效<strong>地在数组中进行操作</strong>，因为堆的结构可以直接映射到数组的索引上，不需要显式使用指针。2i, 2i+1</p>
<p>垂直遍历leetcode.314</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">   3</span><br><span class="line">  /\</span><br><span class="line"> /  \</span><br><span class="line"> 9  20</span><br><span class="line">    /\</span><br><span class="line">   /  \</span><br><span class="line">  15   7</span><br><span class="line">  输入： {3,9,20,#,#,15,7}</span><br><span class="line">输出： [[9],[3,15],[20],[7]]</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; verticalOrder(TreeNode root) {</span><br><span class="line">        // Write your code here</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null) {</span><br><span class="line">            return results;</span><br><span class="line">        }</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = new TreeMap&lt;Integer, List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; qCol = new LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        qCol.offer(0);</span><br><span class="line"></span><br><span class="line">        while(!queue.isEmpty()) {</span><br><span class="line">            TreeNode curr = queue.poll();</span><br><span class="line">            int col = qCol.poll();</span><br><span class="line">            if(!map.containsKey(col)) {</span><br><span class="line">                map.put(col, new ArrayList&lt;Integer&gt;(Arrays.asList(curr.val)));</span><br><span class="line">            } else {</span><br><span class="line">                map.get(col).add(curr.val);</span><br><span class="line">            }</span><br><span class="line">            if(curr.left != null) {</span><br><span class="line">                queue.offer(curr.left);</span><br><span class="line">                qCol.offer(col - 1);</span><br><span class="line">            }</span><br><span class="line">            if(curr.right != null) {</span><br><span class="line">                queue.offer(curr.right);</span><br><span class="line">                qCol.offer(col + 1);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        for(int n : map.keySet()) {</span><br><span class="line">            results.add(map.get(n));</span><br><span class="line">        }</span><br><span class="line">        return results;</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字典序（lexicographical order）是对字符串或序列的一种排序方式，类似于字典中单词的排列顺序。字典序的应用广泛，尤其在字符串处理和排序相关的领域。前缀树（Trie）是一种用于高效存储和检索字符串的树形数据结构，它与字典序有紧密的关系。以下是字典序的应用及其与前缀树的关系：</p>
<h3 id="字典序的应用">字典序的应用</h3>
<ol>
<li><strong>排序</strong>：
<ul>
<li>在编程中，许多排序算法（如快速排序、归并排序）都可以用于对字符串数组按字典序进行排序。</li>
<li>数据库索引常常基于字典序来快速查找记录。</li>
</ul>
</li>
<li><strong>字符串匹配</strong>：
<ul>
<li>在查找字符串或子字符串时，可以利用字典序来优化搜索过程。</li>
</ul>
</li>
<li><strong>字典序列（Lexicographic Permutations）</strong>：
<ul>
<li>生成某个字符串的所有排列并按字典序排序。在某些算法问题中，这种排列方式有助于系统地探索所有可能的情况。</li>
</ul>
</li>
<li><strong>自动补全和拼写检查</strong>：
<ul>
<li>在输入法、搜索引擎和文本编辑器中，按字典序列出的自动补全选项和拼写建议，提高用户体验。</li>
</ul>
</li>
</ol>
<h3 id="前缀树（Trie）与字典序的关系">前缀树（Trie）与字典序的关系</h3>
<p>字典序在字符串处理和排序中有广泛的应用，前缀树是一种高效的数据结构，特别适用于处理字典序相关的问题。通过前缀树，可以快速进行字符串的前缀匹配、自动补全和按字典序的遍历，有助于提升各种应用的性能和效率。</p>
<ol>
<li><strong>结构</strong>：
<ul>
<li>前缀树的每个节点表示一个字符，从根节点到某个节点的路径表示一个字符串。</li>
<li>前缀树按字典序排列子节点，即从根节点遍历时，子节点按字符的字典序排列。</li>
</ul>
</li>
</ol>
<h3 id="前缀和构造多叉树">前缀和构造多叉树</h3>
<p>前缀和处理数组区间问题，<strong>快速得到某个子数组的和</strong></p>
<p>Trie（发音类似 “try”）或者说 前缀树 字典树是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p><strong>前缀和是一种重要的预处理，能大大降低查询的时间复杂度。我们可以简单理解为“数列的前 n 项的和”。这个概念其实很容易理解，即一个数组中，第 n 位存储的是数组前 n 个数字的和。</strong></p>
<p>通过一个例子来进行说明会更清晰。题目描述：有一个长度为 N 的整数数组 A，要求返回一个新的数组 B，其中 B 的第 i 个数 B[i]是<strong>原数组 A 前 i 项和</strong>。</p>
<p>一共有几个和为 <code>k</code> 的子数组。给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>
<p>比如说，我给你输入一个数组 <code>nums</code>，然后又要求给区间 <code>nums[2..6]</code> 全部加 1，再给 <code>nums[3..9]</code> 全部减 3，再给 <code>nums[0..4]</code> 全部加 2，再给…</p>
<p>一通操作猛如虎，然后问你，最后 <code>nums</code> 数组的值是什么？</p>
<p>本文讲一个和前缀和思想非常类似的算法技巧「差分数组」，<strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</strong>。</p>
<p><strong>原数组就是差分数组的前缀和</strong></p>
<h3 id="2559-统计范围内的元音字符串数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-vowel-strings-in-ranges/"><strong>2559. 统计范围内的元音字符串数</strong></a></h3>
<p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 以及一个二维整数数组 <code>queries</code> 。</p>
<p>每个查询 <code>queries[i] = [li, ri]</code> 会要求我们统计在 <code>words</code> 中下标在 <code>li</code> 到 <code>ri</code> 范围内（<strong>包含</strong> 这两个值）并且以元音开头和结尾的字符串的数目。</p>
<p>返回一个整数数组，其中数组的第 <code>i</code> 个元素对应第 <code>i</code> 个查询的答案。</p>
<p>**注意：**元音字母是 <code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code> 和 <code>'u'</code> 。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-vowel-strings-in-ranges/">https://leetcode.cn/problems/count-vowel-strings-in-ranges/</a></p>
<h3 id="2575-找出字符串的可整除数组"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/"><strong>2575. 找出字符串的可整除数组</strong></a></h3>
<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code> ，长度为 <code>n</code> ，由从 <code>0</code> 到 <code>9</code> 的数字组成。另给你一个正整数 <code>m</code> 。</p>
<p><code>word</code> 的 <strong>可整除数组</strong> <code>div</code>  是一个长度为 <code>n</code> 的整数数组，并满足：</p>
<ul>
<li>如果 <code>word[0,...,i]</code> 所表示的 <strong>数值</strong> 能被 <code>m</code> 整除，<code>div[i] = 1</code></li>
<li>否则，<code>div[i] = 0</code></li>
</ul>
<p>返回 **<code>word</code> 的可整除数组。</p>
<p>思路： 如何想到递归求模</p>
<p>first：</p>
<ol>
<li>(a + b) % p = (a % p + b % p) % p （1）</li>
<li>(a - b) % p = (a % p - b % p) % p （2）</li>
<li>(a * b) % p = (a % p * b % p) % p （3）</li>
<li>a ^ b % p = ((a % p)^b) % p （4）</li>
</ol>
<p>second：</p>
<ol>
<li>记<code>N[i]</code>为<code>word[0 ~ i]</code>表示的值。</li>
<li>记<code>n[i]</code>为<code>word[i]</code>表示的数。</li>
<li>不难得出 : <code>N[i] = N[i - 1] * 10 + n[i]</code></li>
<li>在此假设 : <code>N[i - 1] = p * m + q</code>(即余数是<code>q</code>)</li>
<li>那么 : <code>N[i] % m = (p * m * 10) % m + (q * 10 + n[i ] ) % m</code></li>
<li>其中 : <code>(p * m * 10) % m</code>必能整除, 因此只要看后半部分</li>
</ol>
<p><strong>补码</strong>（英语：<strong>2’s complement</strong>）是一种用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%80%B2%E4%BD%8D">二进制</a>表示有符号数的方法，也是一种将数字的正负号变号的方式，常在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8">计算机科学</a>中使用。补码以有符号比特的二进制数定义。</p>
<p>正数和0的补码就是该数字本身再补上最高比特0。负数的补码则是将其<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BB%9D%E5%AF%B9%E5%80%BC">绝对值</a>按位取反再加1。</p>
<p>补码系统的最大优点是可以在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%B3%95">加法</a>或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B8%9B%E6%B3%95">减法</a>处理中，不需因为数字的正负而使用不同的计算方式。只要一种加法电路就可以处理各种有号数加法，而且减法可以用一个数加上另一个数的补码来表示，因此只要有加法电路及补码电路即可完成各种有号数加法及减法，在电路设计上相当方便。几乎所有现代CPU都使用补码来表示和处理整数。这包括 x86, ARM, MIPS 等各种架构。</p>
<p>另外，补码系统的0就只有一个表示方式，这和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%80%E8%A3%9C%E6%95%B8">反码</a>系统不同（在反码系统中，0有二种表示方式），因此在判断数字是否为0时，只要比较一次即可。</p>
<p>右侧的表是一些8-bit补码系统的整数。它的可表示的范围包括-128到127，总共258个整数。n位系统，范围[-2^(n-1),2^(n-1)-1].</p>
<p>例如：10/3=10-3-3-3=1mod3 而减法又可做补码相加，所以所有四则运算的基础都是由加法而来。</p>
<p><strong>以8位二进制数为例，A-B=A-B+256=A+(255-B+1)，11111111-B就是二进制取反，这个式子解释了为什么补码等于反码+1.</strong></p>
<p><strong>对于一个 n 位二进制数x，其补码表示是(2^n - x)</strong></p>
<p><strong>求-5的补码表示：1. 按位取反然后加一</strong></p>
<p><strong>2. (256-5) mod 256</strong></p>
<ul>
<li>251 的二进制表示是：11111011</li>
</ul>
<h2 id="平方根"><strong>平方根</strong></h2>
<p>历史上至少有过两个问题，它们看起来非常困难，非常不像 P 问题，但在人们的不懈努力之下，最终还是成功地加入了 P 问题的大家庭。其中一个是线性规划（linear programming），它是一种起源于二战时期的运筹学模型。1947 年，乔治·丹齐格（George Dantzig）提出了一种非常漂亮的算法叫作“单纯形法”（simplex algorithm），它在随机数据中的表现极为不错，但在最坏情况下却需要耗费指数级的时间。因此，很长一段时间，人们都在怀疑，线性规划是否有多项式级的算法。直到 1979 年，人们才迎来了线性规划的第一个多项式级的算法，它是由前苏联数学家列昂尼德·哈奇扬（Leonid Khachiyan）提出的。</p>
<p>另外一个问题则是质数判定问题（primality test）：判断一个正整数是否是质数（prime），或者说判断一个正整数是不是无法分成两个更小的正整数之积。人们曾经提出过各种质数判定的多项式级算法，但它们要么是基于概率的，要么是基于某些假设的，要么是有一定适用范围的。2002 年，来自印度理工学院坎普尔分校的阿格拉瓦尔（M. Agrawal）、卡亚勒（N. Kayal）和萨克斯泰纳（N. Saxena）发表了一篇重要的论文《PRIMES is in P》，给出了第一个确定性的、时间复杂度为多项式级别的质数判定算法，质数判定问题便也归入了 P 问题的集合。很容易看出，找出一个多项式级的答案<strong>验核</strong>算法，再怎么也比找出一个多项式级的答案<strong>获取</strong>算法更容易。</p>
<p>为了练习函数与循环，判断一个数是否为质数：<strong>我们来实现一个平方根函数：用牛顿法实现平方根函数。</strong></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eede3649-4131-4d14-9733-17f27ded8766/Untitled.png" alt="Untitled"></p>
<p>法一：牛顿迭代法的本质是借助泰勒<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BA%A7%E6%95%B0&amp;spm=1001.2101.3001.7020">级数</a>，从初始值开始快速向零点逼近。</p>
<p>计算机通常使用循环来计算 x 的平方根。从某个猜测的值 z 开始，我们可以根据 z² 与 x 的近似度来调整 z，产生一个更好的猜测：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">z -= (z*z - x) / (2*z)</span><br><span class="line">    long c=x;</span><br><span class="line">        while(c*c&gt;x){</span><br><span class="line">            c = (c+x/c)/2;//怎么得出来的？</span><br><span class="line">        }</span><br><span class="line">    return (int)c;</span><br></pre></td></tr></table></figure>
<p>法二：二分查找逼近</p>
<p>在数学中，<strong>数根</strong>(又称位数根或数字根Digital root)是自然数的一种性质，换句话说，每个自然数都有一个数根。数根是将一正整数的各个位数相加（即横向相加），若加完后的值大于10的话，则继续将各位数进行横向相加直到其值小于十为止[1]，或是，将一数字重复做数字和，直到其值小于十为止，则所得的值为该数的数根。</p>
<p>例如54817的数根为7，因为5+4+8+1+7=25，25大于10则再加一次，2+5=7，7小于十，则7为54817的数根。</p>
<p>数根是一种对数值进行处理的方法，它可以帮助我们快速计算数字的特性，如同余、整除性等，并且可以作为验证计算正确性的方法。主要用途如下：</p>
<ol>
<li><strong>计算模运算的同余</strong>：
<ul>
<li>通过计算数根，可以方便地进行模运算的同余判断。在处理大数字时，数根可以简化计算，节省时间和计算资源。</li>
</ul>
</li>
<li><strong>验证计算正确性</strong>：
<ul>
<li>数字的数根可以用作验证计算结果的正确性的方法。例如，通过对两个数字的数根进行运算，可以检查它们的和的数根是否等于原数字的数根之和。</li>
</ul>
</li>
<li><strong>判断整除性</strong>：
<ul>
<li>数根能够帮助判断一个数是否能被3或9整除。如果一个数字的数根能被3或9整除，那么原始的数字也能被3或9整除。</li>
</ul>
</li>
</ol>
<p>堆的三种操作：</p>
<p>1删除堆顶元素的方法： 常见操作是用数组尾部元素替换堆顶，<strong>这里不直接删除堆顶，因为所有的元素会向前移动一位，会破坏了堆的结构</strong></p>
<p>然后进行下移操作，将新的堆顶和它的子节点进行交换，直到子节点大于等于这个新的堆顶，删除堆顶的时间复杂度为<code>O(logk)</code></p>
<p>2堆化：就是将任意数组调整为堆的结构。</p>
<ol>
<li>任意数组都可以看做一颗完全二叉树</li>
<li>从当前这个完全二叉树的最后一个非叶子节点开始进行元素下沉（siftDown）操作，逐步将这颗二叉树调整为堆结构     buildHeap 第二种 从堆的顶部（数组的开头）开始，并对每个项目调用 siftUp。</li>
</ol>
<p>3 插入</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52320085/article/details/123925981#_3">法一：交换法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52320085/article/details/123925981#_60">法三:哨兵法</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Heap {</span><br><span class="line">  private ArrayList&lt;Integer&gt; data;</span><br><span class="line">  private boolean isMaxHeap;</span><br><span class="line">  public Heap(boolean isMaxHeap) {</span><br><span class="line">      data = new ArrayList&lt;&gt;();</span><br><span class="line">      this.isMaxHeap = isMaxHeap;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">// 建堆</span><br><span class="line">public void buildHeap(int[] arr) {</span><br><span class="line">    for (int num : arr) {</span><br><span class="line">        data.add(num);</span><br><span class="line">    }</span><br><span class="line">    for (int i = parent(data.size() - 1); i &gt;= 0; i--) {</span><br><span class="line">        siftDown(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 插入 在堆中插入新元素后维护堆的性质</span><br><span class="line">public void insert(int num) {</span><br><span class="line">    data.add(num);</span><br><span class="line">    siftUp(data.size() - 1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 删除最大值</span><br><span class="line">public int delete() {</span><br><span class="line">    int res = data.get(0);</span><br><span class="line">    data.set(0, data.get(data.size() - 1));</span><br><span class="line">    data.remove(data.size() - 1);</span><br><span class="line">    siftDown(0);</span><br><span class="line">    return res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 查询最大/小值</span><br><span class="line">public int peek() {</span><br><span class="line">    return data.get(0);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">private void siftUp(int i) {</span><br><span class="line">    while (i &gt; 0 &amp;&amp; data.get(parent(i)).compareTo(data.get(i)) &gt; 0) {</span><br><span class="line">        swap(i, parent(i));</span><br><span class="line">        i = parent(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">private void siftDown(int i) {</span><br><span class="line">    int maxIndex = i;</span><br><span class="line">    int left = leftChild(i);</span><br><span class="line">    if (left &lt; data.size() &amp;&amp; compare(data.get(left), data.get(maxIndex)) &gt; 0) {</span><br><span class="line">        maxIndex = left;</span><br><span class="line">    }</span><br><span class="line">    int right = rightChild(i);</span><br><span class="line">    if (right &lt; data.size() &amp;&amp; compare(data.get(right), data.get(maxIndex)) &gt; 0) {</span><br><span class="line">        maxIndex = right;</span><br><span class="line">    }</span><br><span class="line">    if (i != maxIndex) {</span><br><span class="line">        swap(i, maxIndex);</span><br><span class="line">        siftDown(maxIndex);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">对于任意节点 i，其左子节点的索引为 2i+1，右子节点的索引为 2i+2，而父节点的索引为 floor((i-1)/2)。</span><br><span class="line">private int parent(int i) {</span><br><span class="line">    return (i - 1) / 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">private int leftChild(int i) {</span><br><span class="line">    return 2 * i + 1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">private int rightChild(int i) {</span><br><span class="line">    return 2 * i + 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">private void swap(int i, int j) {</span><br><span class="line">    int temp = data.get(i);</span><br><span class="line">    data.set(i, data.get(j));</span><br><span class="line">    data.set(j, temp);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">private int compare(int a, int b</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Quicksort基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"> func qsort(a []int, rng *rand.Rand) {</span><br><span class="line">    if len(a) &lt; 2 {</span><br><span class="line">        return</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    left, right := 0, len(a)-1</span><br><span class="line"></span><br><span class="line">    // 相当于分区</span><br><span class="line">    pivotIndex := rng.Intn(len(a))</span><br><span class="line">    // Move the pivot to the right</span><br><span class="line">    a[pivotIndex], a[right] = a[right], a[pivotIndex]</span><br><span class="line"></span><br><span class="line">    // Pile elements smaller than the pivot on the left</span><br><span class="line">    for i := range a {</span><br><span class="line">        if a[i] &lt; a[right] {</span><br><span class="line">            a[i], a[left] = a[left], a[i]</span><br><span class="line">            left++</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // Place the pivot after the last smaller element</span><br><span class="line">    a[left], a[right] = a[right], a[left]</span><br><span class="line"></span><br><span class="line">    // Go down the rabbit hole</span><br><span class="line">    qsort(a[:left], rng)</span><br><span class="line">    qsort(a[left+1:], rng)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    rng := rand.New(rand.NewSource(time.Now().UnixNano()))</span><br><span class="line">    arr := []int{3, 6, 8, 10, 1, 2, 1}</span><br><span class="line">    qsort(arr, rng)</span><br><span class="line">    fmt.Println(arr) // Output: [1 1 2 3 6 8 10]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  //三路快排 当序列中有大量的重复元素，二路排序虽然会均衡的分配到两个序列中，但是重复元素仍然参与到分割序列中，带来无谓的性能损耗。</span><br><span class="line"> public void sort(int[] args, int l, int r) {</span><br><span class="line">        if (l &gt;= r) {</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">    int target = args[l];</span><br><span class="line">    int lt = l, gt = r + 1, i = l + 1;</span><br><span class="line">    while (i &lt; gt) {</span><br><span class="line">        if (args[i] &lt; target) {</span><br><span class="line">            swap(args, i, lt + 1);</span><br><span class="line">            lt++;</span><br><span class="line">            i++;</span><br><span class="line">        } else if (args[i] &gt; target) {</span><br><span class="line">            swap(args, i, gt - 1);</span><br><span class="line">            gt--;</span><br><span class="line">        } else {</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    swap(args, l, lt);</span><br><span class="line"></span><br><span class="line">    sort(args, l, lt - 1);</span><br><span class="line">    sort(args, gt, r);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">//快速选择算法</span><br><span class="line">public int findKthLargest(int[] nums, int k) {</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.length - 1;</span><br><span class="line">        int pivot = partition(nums, left, right);</span><br><span class="line">        // 从小到大排序，倒数第k个就是第k个最大元素</span><br><span class="line">        int targetIndex = nums.length - k;</span><br><span class="line"></span><br><span class="line">        while (true) {</span><br><span class="line">            if (pivot == targetIndex) {</span><br><span class="line">                return nums[pivot];</span><br><span class="line">            } else if (pivot &gt; targetIndex) {</span><br><span class="line">                right = pivot - 1;</span><br><span class="line">            } else {</span><br><span class="line">                left = pivot + 1;</span><br><span class="line">            }</span><br><span class="line">            pivot = partition(nums, left, right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int partition(int[] nums, int left, int right) {</span><br><span class="line">        // 基准值索引</span><br><span class="line">        int pivot = left;</span><br><span class="line">        // 预放值索引</span><br><span class="line">        int index = left + 1;</span><br><span class="line">        // 将比基准值小的都紧挨着基准值</span><br><span class="line">        for (int i = index; i &lt;= right; i++) {</span><br><span class="line">            if (nums[i] &lt; nums[pivot]) {</span><br><span class="line">                swap(nums, i, index);</span><br><span class="line">                index++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        // 把基准值移动到比基准值小的数列的最右边</span><br><span class="line">        swap(nums, pivot, index - 1);</span><br><span class="line">        return index - 1;</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>
<p>快速选择算法过一次遍历，确定某一个元素在排序以后的位置，这个算法叫「快速选择」。要理解「快速选择」算法，必须先理解「快速排序」的「partition」。 快速排序会递归处理划分的两边，而选择只处理划分一边。</p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/844a5fb5-852c-475f-8356-33a67426f713/Untitled.png" alt="Untitled"></p>
<h3 id="LRUcache"><strong>LRUcache</strong></h3>
<p>解法</p>
<p>1.LinkedHashmap。<strong>伪头部</strong>（dummy head）和<strong>伪尾部</strong>（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。 当向缓存中添加新项时，如果达到容量限制，将删除链表头部（最少使用）的节点，并更新哈希表。</p>
<p>使用双向链表加哈希表维护get 和 put  O(1) 平均时间复杂度</p>
<p>2.自己实现LinkedHashmap</p>
<ol>
<li>LRU 的功能可以使用双向链表实现，访问到的节点移动到头部，超出容量的从尾部删除。</li>
<li>要实现O(1)得使用HashMap，里面储存 key 与 链表节点即可，这样可以快速定位节点，然后删除它，将它移动到链表头部。</li>
</ol>
<p>3.O（n）解法 好写</p>
<ol>
<li>使用HashMap来存储键值对，其中键是缓存的键，值是对应的缓存项。</li>
<li>使用ArrayList来维护最近访问的顺序，最近访问的项位于列表的末尾。</li>
<li>当访问缓存项时，将其移到ArrayList的末尾，以表明它是最近访问的。</li>
<li>当缓存达到容量限制时，淘汰最近最少使用的项（即ArrayList的头部项）。</li>
</ol>
<p>• ArrayList 中的移除和添加操作是线性时间复杂度 O(n)。但由于在缓存中存储的是键，因此在 ArrayList 中查找和移除元素的复杂度可以视为 O(n)。</p>
<p><strong>LFU 的缓存污染问题：</strong></p>
<p>LFU 通常根据缓存中条目的访问频率来替换最不经常使用的条目。但是，LFU 在某些情况下可能出现“缓存污染”问题：</p>
<p><strong>新数据问题：</strong> 当一些数据被频繁访问但实际上不是常用数据时，它们的频率计数会增加，导致 LFU 将其视为常用数据，长时间占据缓存空间。</p>
<p><strong>突发事件问题：</strong> 在短时间内，某些数据可能会因为特定事件而被频繁访问，这些数据的频率计数可能会暂时性地高于实际常用数据。</p>
<p><strong>LRU 的长环模式问题：</strong></p>
<p>LRU 根据最近最少使用的原则进行缓存替换，但存在一个“长环模式”问题：</p>
<p><strong>周期性访问模式：</strong> 如果存在一组数据被周期性地访问（例如，每隔一段时间访问一次），而且这组数据的访问顺序与 LRU 的缓存替换顺序一致，就会导致这些数据在缓存中形成长环。</p>
<p><strong>替换不及时：</strong> 长环中的数据虽然可能在某段时间内并不频繁使用，但由于周期性访问模式，它们的位置始终位于 LRU 缓存替换算法的末尾，因此不容易被替换出去。</p>
<p><strong>解决方法：</strong></p>
<p>针对这些问题，可以考虑使用一些改进的缓存算法或结合其他策略来提高缓存效率，如：</p>
<p><strong>LFU 的改进版本：</strong> 可以考虑采用 LFU 的变体算法，如动态调整频率计数的算法，以更准确地反映数据的实际热度。</p>
<p><strong>LRU 的改进版本：</strong> 引入时间衰减机制，使得长时间不被访问的数据在一定时间后被逐渐淘汰，而不仅仅依赖于访问顺序。</p>
<p><strong>混合替换策略：</strong> 使用两种或多种不同的缓存替换策略组合，根据具体情况动态选择合适的替换策略。</p>
<p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E8%A8%88%E7%AE%97%E6%80%A7%E7%90%86%E8%AB%96">可计算性理论</a>与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E8%A4%87%E9%9B%9C%E6%80%A7%E7%90%86%E8%AB%96">计算复杂性理论</a>中，所谓的<strong>归约</strong>是将某个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%A8%88%E7%AE%97%E5%95%8F%E9%A1%8C&amp;action=edit&amp;redlink=1">计算问题</a>变换为另一个问题的过程。可用归约法定义某些问题的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A4%87%E9%9B%9C%E5%BA%A6%E9%A1%9E">复杂度类</a>（因变换过程而异）。P NP</p>
<p>以直觉观之，如果存在能有效<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%B1%BA%E5%95%8F%E9%A1%8C">解决问题</a>B的算法，也可以作为解决问题A的子程序，则将问题A称为“可归约”到问题B，因此求解A并不会比求解B更困难。</p>
<p>A(x) = B(f(x)), in other words, for x∈A，there’s f(x)∈B</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Stan ke</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://stan370.github.io/2024/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">https://stan370.github.io/2024/05/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint policy. If reproduced, please indicate source
                    <a href="/about" target="_blank">Stan ke</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E7%BC%96%E7%A8%8B/">
                                    <span class="chip bg-color">编程</span>
                                </a>
                            
                                <a href="/tags/%E7%AE%97%E6%B3%95/">
                                    <span class="chip bg-color">算法</span>
                                </a>
                            
                                <a href="/tags/CS%E5%9F%BA%E7%A1%80/">
                                    <span class="chip bg-color">CS基础</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                    </ul>
                    
                    <div id="wechat">
                        <img src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/medias/reward/wechat.JPG" class="reward-img" alt="微信打赏二维码">
                    </div>
                    <div id="alipay">
                        TBD
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2024/06/06/trust/">
                    <div class="card-image">
                        
                        <img src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/medias/featureimages/trust.jpg" class="responsive-img" alt="信任的本质">
                        
                        <span class="card-title">信任的本质</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-06-06
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E9%9A%8F%E8%B0%88/" class="post-category">
                                    随谈
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E4%BB%B7%E5%80%BC/">
                        <span class="chip bg-color">价值</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/03/11/journal/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/medias/featureimages/14.jpg" class="responsive-img" alt="Personal Thoughts">
                        
                        <span class="card-title">Personal Thoughts</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-03-11
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Stan ke
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/personal-growth/">
                        <span class="chip bg-color">personal growth</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2025</span>
            
            <a href="/about" target="_blank">Stan ke</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/Stan370/stan370.github.io" target="_blank">Matery</a>
            <br>
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;Total Words:&nbsp;<span
                        class="white-color">297.3k</span>
            
            <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;Total visits:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color">Loading...</span>
            </span>
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;Total visitors:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color">Loading...</span>
            </span>
            
            <br>
            <!-- Matomo -->
            <script>
                var _paq = window._paq = window._paq || [];
                /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
                _paq.push(['trackPageView']);
                _paq.push(['enableLinkTracking']);
                (function() {
                    var u="https://your-matomo-instance.com/";
                    _paq.push(['setTrackerUrl', u+'matomo.php']);
                    _paq.push(['setSiteId', '1']);
                    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
                    g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
                })();
            </script>
            <!-- End Matomo Code -->
            <!-- Privacy Notice -->
            <div class="privacy-notice" style="font-size: 0.8em; margin-top: 10px;">
                <i class="fas fa-shield-alt"></i> This site uses Matomo for privacy-friendly analytics.
            </div>
            
            <!-- Busuanzi Debug Info -->
            
            <script>
                // Debug Busuanzi loading
                console.log('Busuanzi enabled, checking elements...');
                setTimeout(function() {
                    var pvElement = document.getElementById('busuanzi_value_site_pv');
                    var uvElement = document.getElementById('busuanzi_value_site_uv');
                    if (pvElement && pvElement.innerHTML === 'Loading...') {
                        console.log('Busuanzi PV still loading, service might be blocked');
                        pvElement.innerHTML = 'Service unavailable';
                    }
                    if (uvElement && uvElement.innerHTML === 'Loading...') {
                        console.log('Busuanzi UV still loading, service might be blocked');
                        uvElement.innerHTML = 'Service unavailable';
                    }
                }, 5000); // Check after 5 seconds
            </script>
            
            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2019";
                        var startMonth = "6";
                        var startDate = "28";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'en';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
    </div>
</footer>

<div class="progress-bar"></div>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
  <div class="modal-content">
    <div class="search-header">
      <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span  >
      <input
        type="search"
        id="searchInput"
        name="s"
        placeholder="Please enter a search keyword"
        class="search-input"
      />
    </div>
    <div id="searchResult"></div>
  </div>
</div>

<script type="text/javascript">
  document.addEventListener('DOMContentLoaded', function() {
    const elems = document.querySelectorAll('.modal');
    const instances = M.Modal.init(elems, {
        dismissible: true,    // Allow modal to be dismissed by clicking outside
        preventScrolling: false, // Allow scrolling while modal is open
        opacity: 0.5,        // Opacity of modal background
        inDuration: 250,     // Transition in duration
        outDuration: 250,    // Transition out duration
        onOpenStart: function() {
            document.body.style.overflow = 'auto';
        },
        onCloseEnd: function() {
            document.body.style.overflow = 'auto';
        }
    });

    // Get modal instance
    const searchModal = document.getElementById("searchModal");
    const modalInstance = M.Modal.getInstance(searchModal);
    
    // Only open modal when search button is clicked
    document.getElementById("openSearchBtn")?.addEventListener("click", function() {
        modalInstance.open();
        searchInput.focus(); 
    });
    function closeSearchModal() {
        modalInstance.close();
    }

    // Handle clicks outside modal
    document.addEventListener("click", function(event) {
        const modalContent = searchModal.querySelector(".modal-content");
        // Check if click is outside modal content
        if (event.target === searchModal && !modalContent.contains(event.target)) {
            closeSearchModal();
        }
    });

    // Add ESC key to close modal
    document.addEventListener("keydown", function(event) {
        if (event.key === "Escape" && searchModal.classList.contains('open')) {
            closeSearchModal();
        }
    });

    var searchFunc = function (path, search_id, content_id) {
      "use strict";
      function debounce(func, wait) {
        let timeout;
        return function () {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, arguments), wait);
        };
      }
      $.ajax({
        url: path,
        dataType: "json",
        success: function (jsonData) {
          // 获取所有文章数据
          console.log(jsonData);
          var datas = jsonData.map(function (post) {
            return {
              title: post.title,
              content: post.content,
              url: post.url,
            };
          });

          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);

          // 搜索输入监听
          $input.addEventListener(
            "input",
            debounce(function () {
              var str = '<ul class="search-result-list">';
              var keywords = this.value
                .trim()
                .toLowerCase()
                .split(/[\s\-]+/);
              $resultContent.innerHTML = "";
              if (this.value.trim().length <= 0) {
                return;
              }
              // Perform local searching
              datas.forEach(function (data) {
                var isMatch = true;
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content
                  .trim()
                  .replace(/<[^>]+>/g, "")
                  .toLowerCase();
                var data_url =
                  data.url.indexOf("/") === 0 ? data.url : "/" + data.url;
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                console.log(data_title, data_content, data_url);
                if (data_title !== "" && data_content !== "") {
                  for (let i = 0; i < keywords.length; i++) {
                    let keyword = keywords[i];
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);

                    if (index_title < 0 && index_content < 0) {
                      isMatch = false;
                      break; // 直接退出关键词遍历
                    } else {
                      if (index_content < 0) {
                        index_content = 0;
                      }
                      if (i === 0) {
                        first_occur = index_content;
                      }
                    }
                  }
                }

                // Show search results
                if (isMatch) {
                  str += `<li>
                <a href="${data_url}" class="search-result-title">${data_title}</a>`;
                  var content = data.content.trim().replace(/<[^>]+>/g, "");
                  if (first_occur >= 0) {
                    var start = Math.max(0, first_occur - 20);
                    var end = Math.min(content.length, first_occur + 80);
                    var match_content = content.substring(start, end);

                    keywords.forEach(function (keyword) {
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(
                        regS,
                        '<em class="search-keyword">$&</em>'
                      );
                    });

                    str += `<p class="search-result">${match_content}...</p>`;
                  }
                  str += "</li>";
                }
              });

              str += "</ul>";
              $resultContent.innerHTML = str;
            }, 300)
          ); // 设置 300 毫秒延迟
        },
        error: function (xhr, status, error) {
          console.error("Search failed:", error);
          document.getElementById(content_id).innerHTML =
            '<p class="search-error">Search failed to load. Please try again.</p>';
        },
      });
    };

    // 初始化搜索
    searchFunc('/search.json', "searchInput", "searchResult");
  });
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/js/matery.js"></script>

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/others/clicklove.js" async="async"></script>
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
