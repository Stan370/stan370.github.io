<!DOCTYPE HTML>
<html lang="en">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="入门学习GO的一些记录, StanBlog">
    <meta name="description" content="Go的优势是什么
计算机一直在演化，但是编程语言并没有以同样的速度演化。现在的手机，内置的 CPU 核 数可能都多于我们使用的第一台电脑。高性能服务器拥有 64 核、128 核，甚至更多核。但是我 们依旧在使用为单核设计的技术在编程。 编程">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>


    <title>入门学习GO的一些记录 | StanBlog</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/css/my.css">

    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="StanBlog" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3592614110969127"
     crossorigin="anonymous"></script>
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">StanBlog</span>
                </a>
            </div>
            
<style>
  #openSearchBtn {
    background: transparent;
    border: none;
    padding: 6px 12px;
    cursor: pointer;
    transition: all 0.3s ease;
  }
#openSearchBtn:hover {
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
}
  #searchIcon {
    color: white;
  }
</style>
<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li>
    <button id="openSearchBtn" type="button" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </button>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">StanBlog</div>
        <div class="logo-desc">
            
            A popular long-form, stick-figure-illustrated blog about almost everything. Material Themes / GitHub Pages 个性化定制的Hexo-Matery主题 
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Stan370/stan370.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Stan370/stan370.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/medias/featureimages/go.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">入门学习GO的一些记录</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">
                                <span class="chip bg-color">计算机基础</span>
                            </a>
                        
                            <a href="/tags/%E7%BC%96%E7%A8%8B/">
                                <span class="chip bg-color">编程</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E7%A8%8B/" class="post-category">
                                计算机工程
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2022-12-07
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    16.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>Read Times:&nbsp;&nbsp;
                    62 Min
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="Go的优势是什么">Go的优势是什么</h2>
<p>计算机一直在演化，但是编程语言并没有以同样的速度演化。现在的手机，内置的 CPU 核 数可能都多于我们使用的第一台电脑。高性能服务器拥有 64 核、128 核，甚至更多核。但是我 们依旧在使用为单核设计的技术在编程。 编程的技术同样在演化。大部分程序不再由单个开发者来完成，而是由处于不同时区、不同 时间段工作的一组人来完成。大项目被分解为小项目，指派给不同的程序员，程序员开发完成后， 再以可以在各个应用程序中交叉使用的库或者包的形式，提交给整个团队。 如今的程序员和公司比以往更加信任开源软件的力量</p>
<p>Go 语言是一种让代码分享更容易的编程语言。Go 语言自带一些工具，让使用别人写的包更容易，并且 Go 语言也让分享自己写的包 更容易。 在本章中读者会看到 Go 语言区别于其他编程语言的地方。<strong>Go 语言对传统的面向对象开发 进行了重新思考，并且提供了更高效的复用代码的手段。Go 语言还让用户能更高效地利用昂贵 服务器上的所有核心，而且它编译大型项目的速度也很快。</strong></p>
<p>在Go语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go语言在这 <strong>3 个条件</strong>之间做到了最佳的平衡：<strong>快速编译，高效执行，易于开发。</strong></p>
<p>Golang快速高效的轻量级<strong>并发支持</strong>，垃圾回收使得其成为开发处理大量后端请求的后端系统首选。在 Go 中部署微服务相对容易</p>
<p><strong>Go uses goroutines and channels to handle concurrency, making the function calls “colorless.” This means there is no need to differentiate between synchronous and asynchronous functions at the syntactic level, simplifying the development process.  Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。</strong></p>
<p>Go 的编译器在逻辑上可以被分成四个阶段：<strong>词法与语法分析、类型检查和 AST 转换、通用 SSA 生成和最后的机器代码生成</strong>，在这一节我们会使用比较少的篇幅分别介绍这四个阶段做的工作，后面的章节会具体介绍每一个阶段的具体内容。</p>
<p>所有的编译过程其实都是从解析代码的源文件开始的，词法分析的作用就是解析源代码文件，它将文件中的<strong>字符串序列转换成 Token 序列，方便后面的处理和解析，我们一般会把执行词法分析的程序称为词法解析器（lexer）</strong>。</p>
<p>而语法分析的输入是词法分析器输出的 Token 序列，语法分析器会按照顺序解析 Token 序列，该过程会将词法分析生成的 Token 按照编程语言定义好的文法（Grammar）自下而上或者自上而下的规约，每一个 Go 的源代码文件最终会被归纳成一个 <a target="_blank" rel="noopener" href="https://golang.org/ref/spec#Source_file_organization">SourceFile</a> 结构<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/#fn:5">5</a>：</p>
<p>Go语言支持交叉编译，比如说你可以在运行 Linux 系统的计算机上开发可以在 Windows 上运行的应用程序。这是第一门完全支持 UTF-8 的编程语言，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。</p>
<p><a target="_blank" rel="noopener" href="https://go.dev/doc/faq#Is_Go_an_object-oriented_language">https://go.dev/doc/faq#Is_Go_an_object-oriented_language</a></p>
<p><strong>强类型静态编译型语言。隐式继承</strong></p>
<p>可以在事后添加接口，而无需注释原始类型。因为类型和接口之间没有明确的关系，所以没有要管理或讨论的类型层次结构。</p>
<p><strong>声明变量</strong></p>
<p>var a string， var 声明自动匹配，</p>
<p>使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明。</p>
<p>如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。</p>
<p>如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。</p>
<p>如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 a：</p>
<p>:=表示声明并赋值，只要:=左边有一个新变量都可以用:=,否则只能用=; 且不能用于声明全局变量</p>
<p><em><strong>iota</strong></em> 是 <em>Go</em> 语言的一个保留字,用作常量计数器。由于 <em>iota</em> 具有自增特性,所以使用iota能简化定义，在定义<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%9E%9A%E4%B8%BE&amp;spm=1001.2101.3001.7020">枚举</a>时很有用。</p>
<p>使用<code>iota</code>时只需要记住以下两点</p>
<p>1.<code>iota</code>在<code>const</code>关键字出现时将被重置为0。</p>
<p>2.<code>const</code>中每新增<strong>一行</strong>常量声明将使<code>iota</code>计数一次(iota可理解为<code>const</code>语句块中的行索引)。</p>
<p>"_"表示匿名变量，无法访问</p>
<p>引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//Go 语言支持匿名函数，可作为闭包。匿名函数是一个"内联"语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</span><br><span class="line">以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量</span><br><span class="line">func getSequence() func() int {</span><br><span class="line">   i:=0</span><br><span class="line">   return func() int {</span><br><span class="line">      i+=1</span><br><span class="line">     return i</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line">   /* nextNumber 为一个函数，函数 i 为 0 */</span><br><span class="line">   nextNumber := getSequence()</span><br><span class="line"></span><br><span class="line">   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line"></span><br><span class="line">   /* 创建新的函数 nextNumber1，并查看结果 */</span><br><span class="line">   nextNumber1 := getSequence()</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><strong>命名规范</strong></p>
<p>1.1 Go是一门区分大小写的语言。</p>
<p>命名规则涉及变量、常量、全局函数、结构、接口、方法等的命名。 Go语言从语法层面进行了以下限定：<strong>任何需要对外暴露的名字必须以大写字母开头，不需要对外暴露的则应该以小写字母开头</strong>。</p>
<ol>
<li>当命名（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Analysize，那么使用这种形式的标识符的对象就<strong>可以被外部包的代码所使用</strong>（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；</li>
<li><strong>命名如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的</strong>（像面向对象语言中的 private ）</li>
</ol>
<p>1.2 包名称</p>
<p>保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为<strong>小写</strong>单词，不要使用下划线或者混合大小写。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> domainpackage main</span><br></pre></td></tr></table></figure>
<p>1.3 文件命名</p>
<p>尽量采取有意义的文件名，简短，有意义，应该为<strong>小写</strong>单词，使用<strong>下划线</strong>分隔各个单词。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">approve_service.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<p>1.4 结构体命名</p>
<ul>
<li>
<p>采用驼峰命名法，首字母根据访问控制大写或者小写</p>
</li>
<li>
<p>struct 申明和初始化格式采用多行，例如下面：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MainConfig <span class="keyword">struct</span> {    Port <span class="type">string</span> <span class="string">`json:"port"`</span>    Address <span class="type">string</span> <span class="string">`json:"address"`</span>}config := MainConfig{<span class="string">"1234"</span>, <span class="string">"123.221.134"</span>}</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>%v 按默认格式输出 %+v 在%v的基础上额外输出字段名 %#v 在%+v的基础上额外输出类型名</p>
<p><strong>defer关键字</strong></p>
<p><strong>defer是当前函数的声明周期结束后才会</strong>出栈**，所以return和defer在一个函数中时return先defer后return**</p>
<p>动态数组传参是引用传递，而且不同元素长度的动态数组形参一致</p>
<ol>
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">  slice := []int{0, 1, 2, 3}</span><br><span class="line">  m := make(map[int]*int)for key, val := range slice {</span><br><span class="line">      m[key] = &amp;val // 这里是将指针指向循环变量 val 的地址</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  for k, v := range m {</span><br><span class="line">      fmt.Println(k, "-&gt;", *v) // 输出 map 中的值</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码输出什么？</p>
<p>问题的根源在于 <strong><code>val</code></strong> 是在循环中声明的，它是一个局部变量。在每次迭代中，<strong><code>val</code></strong> 的值会更新为切片中当前索引位置的值。然而，<strong><code>&amp;val</code></strong> 取得的是变量 <strong><code>val</code></strong> 的地址，而不是其值的地址。</p>
<p>在 <strong><code>for key, val := range slice</code></strong> 循环结束后，<strong><code>val</code></strong> 的值将是迭代完成后的最后一个元素 <strong><code>3</code></strong>。因为 <strong><code>m</code></strong> 中存储的是 <strong><code>&amp;val</code></strong>，也就是 <strong><code>val</code></strong> 的地址，而这个地址在整个循环过程中都没有发生改变，所以无论遍历 <strong><code>m</code></strong> 中的哪个键值对，最终输出的结果都会是 <strong><code>*v</code></strong>，即指向 <strong><code>val</code></strong> 地址的值，也就是 <strong><code>3</code></strong>。</p>
<ol>
<li><strong>new 和 make</strong> 都可以用来分配空间，初始化类型，但是它们确有不同。</li>
</ol>
<p>new(T) 为一个 T 类型新值分配空间并将此空间初始化为 T 的零值，返回的是新值的地址，也就是 T 类型的指针 *T，该指针指向 T 的新分配的零值。<code>p1 := new(int)</code></p>
<p>slice 的零值是 nil，使用 make 之后 slice 是一个初始化的 slice，即 slice 的长度、容量、底层指向的 array 都被 make 完成初始化，此时 slice 内容被类型 int 的零值填充，形式是 [0 0 0]，map 和 channel 也是类似的。</p>
<p><a target="_blank" rel="noopener" href="https://go.dev/doc/faq#Is_Go_an_object-oriented_language">https://go.dev/doc/faq#Is_Go_an_object-oriented_language</a></p>
<p>We decided to take a step back and think about what major issues were going to dominate software engineering in the years ahead as technology developed, and how a new language might help address them. For instance, the rise of multicore CPUs argued that a language should provide first-class support for some sort of concurrency or parallelism. And to make resource management tractable in a large concurrent program, garbage collection, or at least some sort of safe automatic memory management was required.</p>
<p><strong>强类型静态编译型语言。隐式继承</strong></p>
<p>可以在事后添加接口，而无需注释原始类型。因为类型和接口之间没有明确的关系，所以没有要管理或讨论的类型层次结构。</p>
<p>UTF-8 是被广泛使用的编码格式，是文本文件的标准编码，其它包括 XML 和 JSON 在内，也都使用该编码。由于该编码对占用字节长度的不定性，Go 中的字符串也可能根据需要占用 1 至 4 个字节（示例见第 4.6 节），这与其它语言如 C++、Java 或者 Python 不同（Java 始终使用 2 个字节）。Go 这样做的好处是不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。</p>
<h2 id="协程Goroutine">协程Goroutine</h2>
<p>Goroutine的并发编程模型, GC 内存模型 都基于GMP模型，简要解释一下GMP的含义：</p>
<ol>
<li><strong>G（Goroutines）：</strong> Goroutines 是 Go 语言中轻量级线程的抽象，它们是由 Go 运行时管理的并发执行单元。Goroutines 可以看作是函数执行的轻量级版本，它们可以在程序中并发运行，但相比于传统的线程来说，它们的创建和销毁的成本更低，因此可以创建成千上万个 Goroutines 而不会产生太大的开销。</li>
<li><strong>M（Machine）：</strong> M 代表着执行 Goroutines 的执行线程（Machine）。每个物理线程（OS 线程）都对应着一个 M，而 M 负责调度和执行 Goroutines。Go 运行时会维护一个 M 池，用来管理和调度 Goroutines。</li>
<li><strong>P（Processor）：</strong> P 是 G 和 M 之间的调度器。P 的作用是在 M 上运行 Goroutines，P 维护了一个 Goroutines 的队列。P 将 Goroutines 分配给 M 执行，当一个 M 的 Goroutines 执行完毕时，P 会将其分配给其他的 M。</li>
</ol>
<p>Go’s Global Memory Pool (GMP) is a shared memory space where goroutines can access data. It provides a mechanism for goroutines to share variables without explicit synchronization.</p>
<p><strong>How it Works:</strong></p>
<ul>
<li>Goroutines acquire a lock to access the GMP.</li>
<li>The lock is released when the goroutine has finished.</li>
<li>Multiple goroutines can access the GMP concurrently without interfering with each other.</li>
</ul>
<p>In the context of programming languages, “colorless” refers to the uniformity of function calls, where there is no distinction between synchronous and asynchronous functions. This concept contrasts with “colored” functions in languages that require explicit handling of asynchronous operations, such as using <strong><code>async</code></strong> and <strong><code>await</code></strong> keywords.</p>
<h3 id="Colorless-Concurrency-Explained"><strong>Colorless Concurrency Explained</strong></h3>
<h3 id="The-Problem-with-Colored-Functions"><strong>The Problem with Colored Functions</strong></h3>
<p>In languages like JavaScript and Python, asynchronous functions must be explicitly marked with <strong><code>async</code></strong>, and their calls must be awaited using <strong><code>await</code></strong>. This leads to a distinction between synchronous and asynchronous functions, often referred to as “colored” functions. This can introduce complexity in code management because:</p>
<ul>
<li>Every function that interacts with an asynchronous function must also be marked as asynchronous.</li>
<li>The programmer must consistently use <strong><code>await</code></strong> when calling asynchronous functions, which can lead to errors if forgotten.</li>
</ul>
<h3 id="Go’s-Approach-Colorless-Concurrency"><strong>Go’s Approach: Colorless Concurrency</strong></h3>
<p>Go was designed with concurrency as a fundamental feature. Instead of marking functions as asynchronous, <strong>Go uses goroutines and channels to handle concurrency, making the function calls “colorless.” This means there is no need to differentiate between synchronous and asynchronous functions at the syntactic level, simplifying the development process.</strong></p>
<p>Golang不同于其他语言对并发的支持：     例如，用户在写一个 Web 服务器，希望同时处理不同的 Web 请求，如果 使用 C 或者 Java，不得不写大量的额外代码来使用线程。在 Go 语言中，net/http 库直接使用了 内置的 goroutine。每个接收到的请求都自动在其自己的 goroutine 里处理。goroutine 使用的内存 比线程更少，Go 语言运行时会自动在配置的一组逻辑处理器上调度执行 goroutine。每个逻辑处 理器绑定到一个操作系统线程上。这让用户的应用程序执行效率更高，而开发工作量 显著减少。</p>
<p>在目前的绝大多数语言中，都是通过加锁等线程同步方案来解决这一困难问题，Go语言却另辟蹊径，它将共享的值通过Channel传递(实际上多个独立执行的线程很少主动共享资源)。在任意给定的时刻，最好只有一个Goroutine能够拥有该资源。数据竞争从设计层面上就被杜绝了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//go 关键字放在方法调用前新建一个 goroutine 并让他执行方法体</span><br><span class="line">go GetThingDone(param1, param2);</span><br><span class="line"></span><br><span class="line">//上例的变种，新建一个匿名方法并执行</span><br><span class="line">go func(param1, param2) {</span><br><span class="line">}(val1, val2)</span><br><span class="line"></span><br><span class="line">//直接新建一个 goroutine 并在 goroutine 中执行代码块</span><br><span class="line">go {</span><br><span class="line">    //do someting...</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>因为 goroutine 在多核 cpu 环境下是并行的。如果代码块在多个 goroutine 中执行，我们就实现了代码并行。那么问题来了，怎么拿到并行的结果呢？这就得用 channel 了。</strong></p>
<blockquote>
<p>goroutine（go协程）是由Go runtime管理的轻量级线程。</p>
</blockquote>
<p>这句话表明了协程是用户态，因为是由Go runtime管理，而非OS内核管理</p>
<p>并发编程中最常见的例子就是生产者消费者模式，该模式主要通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。简单地说，就是生产者生产一些数据，然后放到成果队列中，同时消费者从成果队列中来取这些数据。这样就让生产消费变成了异步的两个过程。当成果队列中没有数据时，消费者就进入饥饿的等待中；而当成果队列中数据已满时，生产者则面临因产品挤压导致CPU被剥夺的下岗问题。</p>
<h3 id="Channel">Channel</h3>
<p>Yes, it is true that <strong>Go channels are concurrent but not inherently asynchronous</strong>. Let’s break down the details:</p>
<p>Go channels provide a powerful mechanism for safe and efficient communication between goroutines. While the communication itself is synchronous, channels are essential for structuring concurrent programs in Go. If you need true asynchrony (e.g., non-blocking I/O), you might explore techniques like using goroutines with channels for signaling or leverage libraries designed for asynchronous operations.</p>
<p>原子函数和互斥锁都能工作，但是依靠它们都不会让编写并发程序变得更简单，更不容易出错，或者更有趣。在 Go 语言里，你<strong>不仅可以使用原子函数和互斥锁来保证对共享资源的安全访 问以及消除竞争状态，还可以使用通道，通过发送和接收需要共享的资源，在 goroutine 之间做 同步</strong>。</p>
<p>它包括三种类型的定义。可选的<code>&lt;-</code><br>
代表channel的方向。如果没有指定方向，那么Channel就是双向的，既可以接收数据，也可以发送数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    // Send v to channel ch.</span><br><span class="line">v := &lt;-ch  // Receive from ch, and</span><br><span class="line">           // assign value to v.</span><br></pre></td></tr></table></figure>
<p><code>&lt;-</code>总是优先和最左边的类型结合。(The &lt;- operator associates with the leftmost chan possible)</p>
<p>创建管道<code>c := make(chan int)</code></p>
<p>无缓冲的通道（unbuffered channel）是指<strong>在接收前没有能力保存任何值的通道</strong>。这种类型的通 道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。如果两个 goroutine 没有同时准备好，通道会导致<strong>先执行发送或接收操作的 goroutine 阻塞等待</strong>。这种对通道进行发送 和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。</p>
<p><strong>无缓冲通道</strong> (unbuffered channel) 的确会导致发送方 goroutine 和接收方 goroutine <strong>同步化</strong>。</p>
<ul>
<li><strong>发送操作会阻塞</strong>，直到有另一个 goroutine 准备从通道接收数据。</li>
<li><strong>接收操作会阻塞</strong>，直到有另一个 goroutine 准备向通道发送数据。</li>
</ul>
<p>正因为这种同步的特性，无缓冲通道也被称为 <strong>同步通道</strong> (synchronous channel)。</p>
<p>这个特性使得无缓冲通道非常适合用于：</p>
<ol>
<li><strong>保证消息顺序</strong>: 由于发送和接收操作的同步性，无缓冲通道能够保证消息按照发送顺序被接收。</li>
<li><strong>信号量机制</strong>: 可以使用无缓冲通道来实现信号量，例如通知一个 goroutine 另一个 goroutine 已经完成任务。</li>
<li><strong>同步多个 goroutine</strong>: 可以使用无缓冲通道来协调多个 goroutine 的执行，例如等待所有 goroutine 都完成后再进行下一步操作</li>
</ol>
<p><strong>缓冲通道 (buffered channel)</strong> 在 Go 的并发编程中非常有用，尤其适用于以下场景:</p>
<p><strong>1. 缓解生产者和消费者速度差异:</strong></p>
<ul>
<li>当消息的生产速度和消费速度可能出现暂时性不一致时，缓冲通道可以充当队列，存储一部分消息。</li>
<li>生产者可以持续生成消息，无需等待消费者立即处理，避免阻塞。</li>
<li>消费者可以按照自己的节奏从通道中获取消息。</li>
</ul>
<p><strong>2. 允许有限的异步操作:</strong></p>
<ul>
<li>虽然 Go 的通道本质上是同步的，但缓冲通道可以提供一定程度的异步行为。</li>
<li>发送者只有在缓冲区满时才会阻塞，允许一定程度的 “发射后不管” (fire-and-forget) 操作。</li>
</ul>
<p><strong>3. 提高程序吞吐量:</strong></p>
<ul>
<li>在某些情况下，缓冲通道可以提高程序的整体吞吐量。</li>
<li>例如，如果消费者需要处理消息的时间较长，缓冲通道可以让生产者继续生成消息，而不必等待消费者完成。</li>
</ul>
<p><strong>一些具体的例子:</strong></p>
<ul>
<li><strong>日志系统:</strong> 生产者可以快速地将日志消息发送到缓冲通道，而消费者可以异步地将消息写入磁盘。(注意消费者数量，用其他机制保证消息顺序性)</li>
<li><strong>工作队列:</strong> 生产者可以将任务放入缓冲通道，而多个消费者可以并发地从通道中获取任务并执行。</li>
<li><strong>消息传递系统:</strong> 缓冲通道可以用于实现消息队列，允许不同组件之间进行异步通信。</li>
</ul>
<p>默认情况下，在另一端准备好之前，发送和接收都会阻塞。这使得 goroutine 可以在<strong>没有明确的锁或竞态变量的情况下进行同步。</strong></p>
<p>发动和接收数据应当在并行线上，而不能是串行的，因为发送和接收都会阻塞，如果串行，就会死锁（就是一个一直阻塞在那等对端），但不用为此操心，因为go在执行时候（编译会通过）会报错</p>
<p>make的第二个参数指定缓存的大小：<code>ch := make(chan int, 100)</code>。</p>
<p>通过缓存的使用，可以尽量避免阻塞，提供应用的性能。</p>
<p><strong>select</strong>是Golang在语言层面提供的多路IO复用的机制，其可以检测多个channel是否ready(即是否可读或可写)</p>
<p>select中各个case执行顺序是随机的；</p>
<p>如果某个case中的channel已经ready，则执行相应的语句并退出select流程；</p>
<p>如果所有的case的channel都没有ready，则有default会走default然后退出select，没有default，select将阻塞直至channel ready；</p>
<p>case后面不一定是读channel，也可以写channel，只要是对channel的操作就可以；</p>
<p>select {}                        //空的select 语句会永远阻塞，因为没有 goroutine 可以提供任何数据。因此，主协程会引发恐慌并停止僵局。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n*node)</span></span>heartbeatDetect() {</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span>&lt;-n.heartbeat:</span><br><span class="line">    <span class="comment">// 收到心跳信号则退出select等待下一次心跳</span></span><br><span class="line">    breakcase&lt;-time.After(time.Second*<span class="number">3</span>):</span><br><span class="line">    <span class="comment">// 心跳超时，关闭连接</span></span><br><span class="line">          n.conn.Close()</span><br><span class="line">    <span class="keyword">return</span>}</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="垃圾回收GC">垃圾回收GC</h2>
<p>相信很多人对垃圾收集器的印象都是暂停程序（Stop the world，STW），随着用户程序申请越来越多的内存，系统中的垃圾也逐渐增多；当程序的内存占用达到一定阈值时，整个应用程序就会全部暂停，垃圾收集器会扫描已经分配的所有对象并回收不再使用的内存空间，当这个过程结束后，用户程序才可以继续执行，Go 语言在早期也使用这种策略实现垃圾收集，但是今天的实现已经复杂了很多。</p>
<p>Can you explain how Go’s garbage collection works?</p>
<p>所有的 GC 算法其存在形式可以归结为追踪（Tracing）和引用计数（Reference Counting）</p>
<p>memory leak  ignored  finally crash.</p>
<p>Go 使用垃圾收集器来自动管理内存，它负责检测和回收不再被程序使用的内存，以减少内存泄漏和提高性能。</p>
<p>Garbage collection is a mechanism used in programming languages to automatically manage memory by <strong>identifying and reclaiming memory that is no longer in use (garbage), allowing it to be reused.</strong></p>
<p>When a program runs, memory is allocated for various data structures and objects. As the program executes, some of these allocated memory blocks become <strong>unreachable or unreferenced</strong>—meaning they are no longer needed by the program. Garbage collection is responsible for identifying and freeing these unused memory blocks t<strong>o prevent memory leaks and optimize memory usage.</strong></p>
<p>During runtime, the garbage collector scans the memory heap, identifies which objects are reachable (still in use), and identifies those that are unreachable (garbage). It then reclaims the memory occupied by the unreachable objects so that it can be reused for future allocations. apa</p>
<p>For instance, non-pointer Go values stored in the goroutine stack, because go compiler know when to free it.  Go 编译器无法确定其生命周期，无法以这种方式分配内存的 Go 值被称为逃逸到堆。 “堆”可以被认为是内存分配的总称.</p>
<ol>
<li><strong>Tricolor Marking:</strong>
<ul>
<li>Objects in memory are categorized into three colors: white, grey, and black.</li>
<li>Initially, all objects are considered white (unscanned or unvisited).</li>
<li>The GC starts with a set of root objects (global variables, stack references, etc.) and marks them as grey.</li>
<li>It traverses through the object graph, marking reachable objects as grey and adding them to a work queue.</li>
<li>As the GC progresses, grey objects turn black, indicating that they have been scanned and all their references have been examined.</li>
<li>Objects that remain white after this process are considered unreachable (garbage).</li>
</ul>
</li>
<li><strong>Concurrent Marking:</strong>
<ul>
<li>Go’s garbage collector performs garbage collection concurrently with the program’s execution, reducing stop-the-world pauses.</li>
<li>While the garbage collection is in progress, the application can continue running, except for short stop-the-world phases necessary for specific tasks like stack scanning.</li>
</ul>
</li>
<li><strong>Sweeping and Reclamation:</strong>
<ul>
<li>Once the marking phase is complete, the sweep phase identifies all white (unmarked) objects and reclaims their memory.</li>
<li>The memory is then added back to the heap for future allocations.p</li>
</ul>
</li>
</ol>
<p>Golang在GC的演进过程中也经历了很多次变革，大概分为**「3个阶段」**</p>
<ul>
<li>Go V1.3之前的标记-清除法(mark and sweep) 清除比标记和扫描快得多</li>
<li>Go V1.5的三色并发标记法</li>
<li>Go V1.8混合写屏障机制</li>
</ul>
<p>垃圾收集（GC）的<strong>频率和启动时间对于 CPU 时间和内存之间的权衡</strong>至关重要。GC 的执行频率由 GOGC 参数决定，它影响着 GC 应该启动的时间以及内存回收的程度。</p>
<p>例如，将 GOGC 设置为 100（默认值为 100），表示在分配了大约 100 个新对象后触发 GC。<strong>加倍 GOGC 将使堆内存开销加倍，并使 GC CPU 成本大致减半.</strong></p>
<p><strong>就延迟而言，stop-the-world GC 可能需要相当长的时间来执行其标记和清除阶段 降低 GC 频率也可能会导致延迟改善</strong></p>
<p>Tracing garbage collection（追踪式垃圾收集）是一种垃圾回收（GC）算法，通常应用于动态内存管理系统中。从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆，并标记哪些对象是活跃的（可达的），然后清理那些未被标记的对象。</p>
<p>最传统的标记清除算法，垃圾收集器从垃圾收集的根对象出发，递归遍历这些对象指向的子对象并将所有可达的对象标记成存活；标记阶段结束后，垃圾收集器会依次遍历堆中的对象并清除其中的垃圾，整个过程需要标记对象的存活状态，用户程序在垃圾收集的过程中也不能执行，我们需要用到更复杂的机制来解决 STW 的问题。</p>
<p>追踪式垃圾收集相对于其他算法（比如引用计数等）有其优势和劣势。<strong>优势在于它能够处理循环引用（Circular references）并回收垃圾，但是劣势在于它可能引起暂停（停顿式垃圾收集），即在标记和清理的过程中，会暂停应用程序的执行。</strong></p>
<p>虽然 Go 语言的垃圾回收会有一些额外的开销，但是编程时，能显著降低开发难度。Go 语言把无趣的内存管理交给专业的编译器去做，而让程序员专注于更有趣的事情。</p>
<p>程序运行时将所使用的内存划分成两部分：</p>
<ol>
<li>
<ol>
<li>栈（Stack） 函数的局部内存空间，用于保存函数的局部变量，也包括函数调用时的参数、返回值。栈内存与函数的生命周期完全一致，在函数调用时创建、退出时销毁，由程序自动管理，并且栈上数据仅对当前函数可见，因此，只要内存使用的生命周期在函数生命周期之内，都可以分配栈上的空间。 栈更加高效与安全，但对于使用场景有严格限制。</li>
</ol>
</li>
<li>
<ol start="2">
<li>堆（Heap） 全局内存空间，由整个程序共享。堆内存的分配与释放需要单独管理，像C语言有专门的分配与释放内存的内置函数，但现在几乎所有的高级编程语言都提供了自动的内存管理策略，Go 语言便是其中之一。由于堆内存的全局可见性，还需要保证并发访问下数据的同步性。 堆更加灵活，但面临着更复杂的管理问题，为程序带来了额外的开销。</li>
</ol>
</li>
</ol>
<p>由此可见，对于一个内存区域，它在程序中的可见范围决定了应该使用哪种内存：如果该内存区域的可见范围跨越了多个函数，那么就必须使用堆内存，而如果其可见范围仅仅局限于一个函数之内，则可以优先考虑栈空间。</p>
<p>程序的变量就是对内存区域的抽象，因此，对变量的可见范围（作用域）进行分析，进而判断应该将其分配到栈上还是堆上的过程，叫着<strong>逃逸分析</strong>。即为了简化内存管理，我们默认所有变量都使用栈空间，但如果一个变量由于被多个函数所引用，必须将其转移到堆上，我们就说该变量“逃逸”到了堆上。</p>
<p><strong>语法糖</strong></p>
<p>‘…’ 其实是go的一种语法糖。用法一：表示多个不确定数量的参数</p>
<p>用法二：slice打散传递</p>
<ol>
<li>arr2 := []int{1,2,3}</li>
<li>arr1 = append(arr1,0)</li>
<li>arr1 = append(arr1,<strong>arr2…</strong>)</li>
</ol>
<h3 id="数据类型">数据类型</h3>
<p>Go语言中数组、字符串和切片三者是密切相关的数据结构。这三种数据类型，在底层原始数据有着相同的内存结构，在上层，因为语法的限制而有着不同的行为表现。首先，<strong>Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的</strong>。Go语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改。字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制。切片的行为更为灵活，切片的结构和字符串结构类似，但是解除了只读限制。切片的底层数据虽然也是对应数据类型的数组，但是每个切片还有独立的长度和容量信息，切片赋值和函数传参数时也是将切片头信息部分按传值方式处理。因为切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制。其实Go语言的赋值和函数传参规则很简单，除了闭包函数以引用的方式对外部变量访问之外，其它赋值和函数传参数都是以传值的方式处理。要理解数组、字符串和切片三种不同的处理方式的原因需要详细了解它们的底层数据结构。</p>
<p>数组是一个由<strong>固定长度</strong>的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。数组的长度是数组类型的组成部分。因为数组的长度是数组类型的一个部分，不同长度或不同类型的数据组成的数组都是不同的类型，因此在Go语言中很少直接使用数组（不同长度的数组因为类型不同无法直接赋值）。和数组对应的类型是切片，切片是可以动态增长和收缩的序列，切片的功能也更加灵活，但是要理解切片的工作原理还是要先理解数组。</p>
<p>转换:   Atoi (string to int) and Itoa (int to string).</p>
<ul>
<li><strong><code>strconv.Itoa</code></strong>：用于将整数转换为字符串表示，例如将整数 5 转换为字符串 “5”。</li>
<li><strong><code>string(int)</code></strong>：将整数解释为 Unicode 码点并转换为相应的字符，这在处理字符串压缩时并不适用。</li>
</ul>
<p>rune类型是Go语言中的一个基本类型，其实就是一个<strong>int32的别名</strong><br>
，主要用于表示一个字符类型大于一个字节小于等于4个字节的情况下，特别是<strong>中文字符。</strong></p>
<p>. A <code>byte</code> has a limit of 0 – 255 in numerical range. It can represent an ASCII character.</p>
<p>在 Go 语言中，<strong><code>byte</code></strong> 是 <strong><code>uint8</code></strong> 类型的别名，表示一个 8 位无符号整数。它主要用于表示原始的二进制数据，如文件内容、网络数据包等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println([]byte("falcon"))</span><br><span class="line">     fmt.Println([]byte("čerešňa"))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">$ go run str2bytes.go</span><br><span class="line">[102 97 108 99 111 110]</span><br><span class="line">[196 141 101 114 101 197 161 197 136 97]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据内存和性能来看，在函数间传递<strong>大数组</strong>是一个开销很大的操作。在函数之间传递变量时，总是以值的方式传递的。如果这个变量是一个数组，意味着整个数组，不管有多长，都会完整复制，并传递给函数。</p>
<p>指针的一个应用是你可以传递一个变量的引用（如函数的参数），这样不会传递变量的拷贝。指针传递是很廉价的，只占用 4 个或 8 个字节。当程序在工作中需要占用大量的内存，或很多变量，或者两者都有，使用指针会减少内存占用和提高效率。被指向的变量也保存在内存中，直到没有任何指针指向它们，所以从它们被创建开始就具有相互独立的生命周期。</p>
<h2 id="Slice切片">Slice切片</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> {</span><br><span class="line">  array unsafe.Pointer</span><br><span class="line">  <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">  <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>编译期间的切片是 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/cmd/compile/internal/types.Slice"><code>cmd/compile/internal/types.Slice</code></a> 类型的，但是在运行时切片可以由如下的 <a target="_blank" rel="noopener" href="https://draveness.me/golang/tree/reflect.SliceHeader"><code>reflect.SliceHeader</code></a> 结构体表示，其中:</p>
<ul>
<li><code>Data</code> 是指向数组的指针;</li>
<li><code>Len</code> 是当前切片的长度；</li>
<li><code>Cap</code> 是当前切片的容量，即 <code>Data</code> 数组的大小：</li>
</ul>
<p>在Go中，切片是一种动态数组的抽象，它提供了一种方便且灵活的方式来处理数据集合。切片本身并不包含数据，而是<strong>对底层数组的一个引用</strong>，并提供了对该数组局部的访问。</p>
<p>以下是关于切片的一些关键概念：</p>
<ol>
<li><strong>底层数组：</strong> 切片是建立在数组的基础之上的。切片不拥有自己的数据，而是引用一个底层数组，这个数组负责实际的存储。当切片被创建时，底层数组会被分配一段空间，切片的操作实际上是在这个空间内进行的。</li>
<li><strong>切片的传递：</strong> 切片是引用类型，当切片作为参数传递给函数时，函数接收的是切片的引用。因此，在函数内对切片的修改会影响到调用者的切片。</li>
</ol>
<p>**切片本身是一个只读对象，其工作机制类似数组指针的一种封装。**切片常见的操作有 reslice、append、copy。与此同时，切片还具有可索引，可迭代的优秀特性。</p>
<p>在对slice进行append等操作时，可能会造成slice的自动扩容。其扩容时的大小增长规则是：</p>
<ol>
<li>如果期望容量大于当前容量的两倍就会使用期望容量；</li>
<li>如果当前切片的长度小于 1024 就会将容量翻倍；</li>
<li>如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；</li>
</ol>
<p>在 Go 语言中，切片是引用类型。当你将一个切片作为参数传递给函数时，实际上传递的是切片的副本，但这个副本指向的是相同底层数组（底层数据结构）。</p>
<p>传递切片时，副本包括了切片本身的一些元数据信息（如指向底层数组的指针、长度、容量等），但它们共享相同底层数组的数据。</p>
<p><strong>因此，在函数内部对传递的切片的修改（例如修改切片中的元素值）会影响到原始切片指向的相同底层数组的数据。但如果在函数内部重新分配了新的底层数组给传递的切片，或者修改了切片的长度和容量等元数据信息，这些修改不会影响到原始切片</strong>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">func <span class="title function_">modifySlice</span>(<span class="params">s []int</span>) {</span><br><span class="line">    <span class="comment">// 在函数内修改切片元素</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">    s = <span class="title function_">append</span>(s, <span class="number">200</span>) <span class="comment">// 在此追加元素，但不会影响原始切片的长度或容量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) {</span><br><span class="line">    original := []int{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}</span><br><span class="line">    fmt.<span class="title class_">Println</span>(<span class="string">"Original Slice:"</span>, original)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">modifySlice</span>(original)</span><br><span class="line">    fmt.<span class="title class_">Println</span>(<span class="string">"After Modification:"</span>, original)<span class="comment">//100,2,3,4,5</span></span><br><span class="line"></span><br><span class="line">    slice := <span class="title function_">make</span>([]int, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">    slice1 := slice[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">    slice2 := <span class="title function_">append</span>(slice1, <span class="number">1</span>)</span><br><span class="line">    slice2 = <span class="title function_">append</span>(slice2, <span class="number">1</span>)</span><br><span class="line">    slice2[<span class="number">0</span>] = <span class="number">10001</span></span><br><span class="line">    fmt.<span class="title class_">Println</span>(slice)                                <span class="comment">//【0,0】</span></span><br><span class="line">    fmt.<span class="title class_">Println</span>(slice1)         <span class="comment">// [0]</span></span><br><span class="line">    fmt.<span class="title class_">Println</span>(<span class="title function_">cap</span>(slice2))    <span class="comment">//18</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="深拷贝与浅拷贝的区别"><strong>深拷贝与浅拷贝的区别</strong></h3>
<ol>
<li><strong>修改后的影响</strong>：
<ul>
<li>浅拷贝：修改拷贝对象的嵌套元素会影响原对象，因为它们共享相同的嵌套对象。</li>
<li>深拷贝：修改拷贝对象不会影响原对象，因为所有嵌套对象都被复制了。</li>
</ul>
</li>
<li><strong>性能</strong>：
<ul>
<li>浅拷贝：性能较好，因为只复制顶层结构，嵌套对象仍然共享。</li>
<li>深拷贝：性能较差，因为需要递归复制所有嵌套对象，尤其是对于深层次嵌套的对象结构。</li>
</ul>
</li>
</ol>
<h3 id="实际应用"><strong>实际应用</strong></h3>
<p>深拷贝和浅拷贝在实际编程中有不同的应用场景：</p>
<ul>
<li><strong>浅拷贝</strong>：适用于简单数据结构，或者在需要共享数据的场景下。</li>
<li><strong>深拷贝</strong>：适用于需要独立副本的数据结构，特别是在并发编程或多线程环境中，以避免数据竞争和不一致性。</li>
</ul>
<p>在 Go 语言中，<strong><code>copy</code></strong> 函数并不执行深拷贝，而是执行浅拷贝。<strong><code>copy</code></strong> 函数用于将一个源切片的元素复制到目标切片中，但只会复制切片中的元素值   如果切片的元素是引用类型（例如，指向结构体或切片等），<strong><code>copy</code></strong> 函数只会复制引用，而不会复制引用指向的实际数据。这意味着对目标切片中的引用类型元素的修改将影响源切片中相应的元素，因为它们引用的是相同的底层数组中的对象。</p>
<p>分析可以发现，“Hello, world”字符串底层数据和以下数组是完全一致的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var data = [...]byte{</span><br><span class="line">    'h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd',</span><br><span class="line">}</span><br><span class="line">沟通一个切片的开闭，需要约定一个前提: 语境的开始从0开始，开始从1开始（通常情况从下标0开始）</span><br><span class="line">左闭右开</span><br><span class="line"></span><br><span class="line">**new := old[5:]，使用 [start:] 的形式截取，推荐</span><br><span class="line">new := old[5:len(old)-1]，通过计算原数组长度，截取从开始下标至最后一个下标（由于下标从0开始，所以长度减一）**</span><br></pre></td></tr></table></figure>
<p>切片的行为更为灵活，切片的结构和字符串结构类似，但是解除了只读限制。切片的底层数据虽然也是对应数据类型的数组，但是每个切片还有独立的长度和容量信息，切片赋值和函数传参数时也是将切片头信息部分按传值方式处理。因为切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制。</p>
<h3 id="String">String</h3>
<p>在 Go 中，遍历字符串（string）时，可以使用 <strong><code>range</code></strong> 关键字来遍历字符串的 Unicode 码点（code point）。因为 Go 中的字符串是不可变的字节序列，而且每个字符可能由多个字节组成，因此使用 <strong><code>range</code></strong> 关键字能够更好地处理 Unicode 字符。</p>
<p>在 Go 语言中，字符串底层实际上是一个字节（byte）数组，也就是说，字符串中的每个字符在底层都是由一个或多个字节（byte）表示的。但是，当我们遍历或处理字符串时，字符可以被视为 <strong><code>rune</code></strong> 或 <strong><code>byte</code></strong>，具体取决于使用的方式。</p>
<h3 id="字符串中的字符表示"><strong>字符串中的字符表示</strong></h3>
<ol>
<li><strong>字节（byte）表示</strong>：
<ul>
<li>当直接通过索引访问字符串的元素时，得到的是 <strong><code>byte</code></strong> 类型。<strong><code>byte</code></strong> 是 <strong><code>uint8</code></strong> 的别名，表示一个无符号的 8 位整数。</li>
<li>字符串在内存中是以 UTF-8 编码存储的，每个字符可能由一个或多个字节组成。</li>
</ul>
</li>
<li><strong>Unicode 代码点（rune）表示</strong>：
<ul>
<li>当使用 <strong><code>for range</code></strong> 遍历字符串时，得到的是 <strong><code>rune</code></strong> 类型。</li>
<li><strong><code>rune</code></strong> 是 <strong><code>int32</code></strong> 的别名，用于表示 Unicode 代码点。</li>
<li><strong><code>rune</code></strong> 可以表示所有的 Unicode 字符，包括那些需要多个字节表示的字符。</li>
</ul>
</li>
</ol>
<p>string与[]byte在底层结构上是非常的相近（后者的底层表达仅多了一个cap属性，因此它们在内存布局上是可对齐的），这也就是为何builtin中内置函数copy会有一种特殊情况<code>copy(dst []byte, src string) int</code>的原因了。对于[]byte与string而言，<strong>两者之间最大的区别就是string的值不能改变</strong></p>
<p>字符串的值不能被更改，但可以被替换。 string在底层都是结构体<code>stringStruct{str: str_point, len: str_len}</code>，string结构体的str指针指向的是一个字符常量的地址， 这个地址里面的内容是不可以被改变的，因为它是只读的，但是这个指针可以指向不同的地址。</p>
<p>那么，以下操作的含义是不同的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := "S1" // 分配存储"S1"的内存空间，s结构体里的str指针指向这块内存</span><br><span class="line">s = "S2"  // 分配存储"S2"的内存空间，s结构体里的str指针转为指向这块内存</span><br><span class="line"></span><br><span class="line">b := []byte{1} // 分配存储'1'数组的内存空间，b结构体的array指针指向这个数组。</span><br><span class="line">b = []byte{2}  // 将array的内容改为'2'</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Golang 有 time.Time数据类型来处理挂钟时间和time.Duration来处理单调时间。 第一个基本方法是 time.Now()，它返回当前日期和时间，精确到纳秒。返回的值具有数据类型 time.Time，它是一个结构。根据 Golang 的官方文档，“A Time 代表具有纳秒精度的瞬间”。</p>
<p><strong>time.Duration</strong>有一个基本类型 int64。持续时间表示两个瞬间之间经过的时间，以 int64 纳秒计数”。最大可能的纳秒表示可达 290 年。</p>
<h2 id="指针-传参">指针,传参</h2>
<ul>
<li>Go 中函数<strong>传参仅有值传递</strong>一种方式；</li>
<li><strong>slice</strong>、<strong>map</strong>、<strong>channel</strong>都是引用类型，但是跟c++的不同；</li>
<li><strong>slice</strong>能够通过函数传参后，修改对应的数组值，是因为 slice 内部保存了引用数组的指针，并不是因为引用传递。</li>
</ul>
<blockquote>
<p>go 中，slice、map、channel都是引用类型，所以都会有如上的特性。</p>
</blockquote>
<p>在默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p>
<p>注意1：无论是值传递，还是引用类型传递，传递给函数的都是变量的副本，不过，值传递是值的拷贝。引用传递是地址的拷贝，一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。</p>
<p>注意2：map、slice、chan、指针、interface默认以引用的方式传递。</p>
<p>不定参数传值 就是函数的参数不是固定的，后面的类型是固定的。（可变参数）</p>
<p>匿名函数的定义就是没有名字的普通函数定义。</p>
<p><strong>Go 中数组赋值和函数传参都是值复制的。那这会导致什么问题呢？</strong></p>
<p>假想每次传参都用数组，那么每次数组都要被复制一遍。如果数组大小有 100万，在64位机器上就需要花费大约 800W 字节，即 8MB 内存。这样会消耗掉大量的内存。于是乎有人想到，函数传参用数组的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">slice1 := make(int[],3)  //声明切片并分配空间初始值为0</span><br><span class="line"></span><br><span class="line">var slice2 = []int</span><br><span class="line">//Objective-C, Swift, Ruby, Lua中的关键字，与C++里的NULL不同，NULL是一个宏定义，值为0，nil表示无值</span><br><span class="line">if slice2==nil{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">//追加元素,如果append时超过容量cap，容量将自动变为2倍</span><br><span class="line">numbers = append(numbers,2)</span><br></pre></td></tr></table></figure>
<p>nil 指针也称为空指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var a int= 20   /* 声明实际变量 */</span><br><span class="line">   var ip *int        /* 声明指针变量 */</span><br><span class="line"></span><br><span class="line">   ip = &amp;a  /* 指针变量的存储地址 */</span><br><span class="line"></span><br><span class="line">   fmt.Printf("a 变量的地址是: %x\\n", &amp;a  )</span><br><span class="line"></span><br><span class="line">   /* 指针变量的存储地址 */</span><br><span class="line">   fmt.Printf("ip 变量储存的指针地址: %x\\n", ip )</span><br><span class="line">   /* 使用指针访问值 */</span><br><span class="line">   fmt.Printf("*ip 变量的值: %d\\n", *ip )</span><br><span class="line">普通占位符</span><br><span class="line">占位符     说明                           举例                   输出</span><br><span class="line">%v      相应值的默认格式。            Printf("%v", people)   {zhangsan}，</span><br><span class="line">%+v     打印结构体时，会添加字段名     Printf("%+v", people)  {Name:zhangsan}</span><br><span class="line">%#v     相应值的Go语法表示            Printf("#v", people)   main.Human{Name:"zhangsan"}</span><br><span class="line">%T      相应值的类型的Go语法表示       Printf("%T", people)   main.Human</span><br><span class="line">%%      字面上的百分号，并非值的占位符  Printf("%%")            %</span><br><span class="line">布尔占位符</span><br><span class="line">占位符       说明                举例                     输出</span><br><span class="line">%t          true 或 false。     Printf("%t", true)       true</span><br><span class="line">整数占位符</span><br><span class="line">占位符     说明                                  举例                       输出</span><br><span class="line">%b      二进制表示                             Printf("%b", 5)             101</span><br><span class="line">%c      相应Unicode码点所表示的字符              Printf("%c", 0x4E2D)        中</span><br><span class="line">%d      十进制表示                             Printf("%d", 0x12)          18</span><br><span class="line">%o      八进制表示                             Printf("%d", 10)            12</span><br><span class="line">%q      单引号围绕的字符字面值，由Go语法安全地转义 Printf("%q", 0x4E2D)        '中'</span><br><span class="line">%x      十六进制表示，字母形式为小写 a-f         Printf("%x", 13)             d</span><br><span class="line">%X      十六进制表示，字母形式为大写 A-F         Printf("%x", 13)             D</span><br><span class="line">%U      Unicode格式：U+1234，等同于 "U+%04X"   Printf("%U", 0x4E2D)         U+4E2D</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Map">Map</h3>
<p>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p>
<p>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的<strong>返回顺序，这是因为 Map 是使用 hash 表</strong>来实现的。</p>
<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/ea503cf6-9325-47ab-9fb3-3e33e40583ef/ed7dc340-8912-4511-bc8c-ded0e638ab91/Untitled.png" alt="Untitled"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*查看元素在集合中是否存在 */</span><br><span class="line">    capital, ok := countryCapitalMap [ "American" ] /*如果确定是真实的,则存在,否则不存在 */</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>[mapstructure](&lt;https://github.com/mitchellh/mapstructure&gt;)</code><br>
用于将通用的<code>map[string]interface{}</code>解码到对应的 Go 结构体中，或者执行相反的操作。很多时候，解析来自多种源头的数据流时，我们一般事先<strong>并不知道他们对应的具体类型</strong>。只有读取到一些字段之后才能做出判断。这时，<strong>我们可以先使用标准的<code>encoding/json</code>库将数据解码为<code>map[string]interface{}</code>类型，然后根据标识字段利用<code>mapstructure</code><br>
库转为相应的 Go 结构体以便使用</strong></p>
<h2 id="function方法">function方法</h2>
<p>A method is on an object or is static in class.A function is independent of any object (and outside of any class).</p>
<p>For Java and C#, there are only methods.</p>
<p>For C, there are only functions.</p>
<p>For C++ and Python it would depend on whether or not you’re in a class.</p>
<h3 id="1-在定义时调用匿名函数">1) 在定义时调用匿名函数</h3>
<p>匿名函数lambda：是指<strong>一类无需定义标识符（函数名）的函数或子程序</strong><br>
。 所谓匿名函数，通俗地说就是没有名字的函数，lambda函数没有名字，是一种简单的、在同一行中定义函数的方法。 lambda函数一般功能简单：单行expression决定了lambda函数不可能完成复杂的逻辑，只能完成非常简单的功能。</p>
<p>匿名函数可以在声明后调用，例如：<br>
<code>1. func(data int) { 2.     fmt.Println("hello", data) 3. }(100)</code></p>
<p>表示对匿名函数进行调用，传递参数为 100。</p>
<ol>
<li>将匿名函数赋值给变量</li>
</ol>
<p>匿名函数可以被赋值，例如：<br>
<code>1. // 将匿名函数体保存到f()中 2. f := func(data int) { 3.     fmt.Println("hello", data) 4. } 5.  6. // 使用f()调用 7. f(100)</code></p>
<p>匿名函数的用途非常广泛，它本身就是一种值，可以方便地保存在各种容器中实现回调函数和操作封装。</p>
<p>What is () before a function Golang?</p>
<p>it’s called receiver argument, 函数名前的括号规定了接收到的object,就像面向对象的类,想要调用Person类中的eat方法首先需要创建一个Person对象</p>
<p>The parenthesis before the function name is <strong>the Go way of defining the object on which these functions will operate</strong>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Vertex struct {</span><br><span class="line">  X, Y float64</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (v Vertex) Abs() float64 {</span><br><span class="line">  return math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">  v := Vertex{3, 4}</span><br><span class="line">  fmt.Println(v.Abs())</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>闭包和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">匿名函数</a>经常被用作同义词。但严格来说，匿名函数就是字面意义上没有被赋予名称的函数，而闭包则实际上是一个函数的实例，也就是说它是存在于内存里的某个结构体。如果从实现上来看的话，匿名函数如果没有捕捉自由变量，那么它其实可以被实现为一个函数指针，或者直接内联到调用点，如果它捕捉了自由变量那么它将是一个闭包；而闭包则意味着同时包括函数指针和环境两个关键元素。在编译优化当中，没有捕捉自由变量的闭包可以被优化成普通函数，这样就无需分配闭包结构体，这种编译技巧被称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%87%BD%E6%95%B0%E8%B7%83%E5%8D%87&amp;action=edit&amp;redlink=1">函数跃升</a></p>
<h3 id="闭包">闭包</h3>
<p><strong>闭包</strong>（closure）是一个函数以及其捆绑的周边环境状态（<strong>lexical environment</strong>，<strong>词法环境</strong>）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。</p>
<p>闭包使得Javascript的垃圾回收机制GC不会收回a()所占用的资源，因为a()的内部函数b()的执行需要依赖a()中的变量i</p>
<p>defer <code>这些调用直到 return 前才被执。因此，可以用来做资源清理。</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "fmt"</span><br><span class="line">type Test struct {</span><br><span class="line">    name string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (t *Test) Close() {</span><br><span class="line">    fmt.Println(t.name, " closed")</span><br><span class="line">}</span><br><span class="line">func Close(t Test) {</span><br><span class="line">    t.Close()</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    ts := []Test{{"a"}, {"b"}, {"c"}}</span><br><span class="line">    for _, t := range ts {</span><br><span class="line">        defer Close(t)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>defer后面的语句在执行的时候，函数调用的参数会被保存起来，但是不执行。也就是复制了一份。但是并没有说struct这里的this指针如何处理，通过这个例子可以看出go语言并没有把这个明确写出来的this指针当作参数来看待。</p>
<p>多个 defer 注册，按 FILO 次序执行 ( 先进后出 )。哪怕函数或某个延迟调用发生错误，这些调用依旧会被执行。</p>
<p><strong>尽可能不要在goroutine中使用闭包!</strong></p>
<h2 id="Exception">Exception</h2>
<p>Golang 没有结构化异常，使用 panic 抛出错误，recover 捕获错误。</p>
<p>异常的使用场景简单描述：Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。</p>
<p>Python&amp;Java try-catch 机制正是提案试图避免的那种事情。 Panic 和 recover 不是通常意义的异常机制。通常的方式是将 exception 和一个控制结构相关联，鼓励细粒度的 exception 处理，导致代码往往不易阅读。在 error 和调用一个 panic 之间确实存在差异，而且我们希望这个差异很重要。在 Java 中打开一个文件会抛出异常。在我的经验中，打开文件失败是最平常不过的事。而且还需要我写许多代码来处理这样的 exception。</p>
<h3 id="Difference"><strong>Difference:</strong></h3>
<ul>
<li><strong><code>log.Panicln()</code></strong> is used to log an error message and then trigger a panic, providing some context or details about the error <strong>before</strong> the program exits due to the panic.</li>
<li><strong><code>panic()</code></strong> is used to immediately halt the program’s execution without providing additional context or logging. It is usually used for unrecoverable errors where the program cannot continue.</li>
</ul>
<h2 id="Reflect">Reflect</h2>
<p>反射是指程序在运行时runtime <strong>检查其自身结构并根据该信息修改其行为的能力</strong>。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p>
<p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。C/<a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>语言没有支持反射功能，只能通过 typeid 提供非常弱化的程序运行时类型信息；Java、<a target="_blank" rel="noopener" href="http://c.biancheng.net/csharp/">C#</a> 等语言都支持完整的反射功能；Lua、<a target="_blank" rel="noopener" href="http://c.biancheng.net/js/">JavaScript</a>类动态语言，由于其<strong>本身的语法特性就可以让代码在运行期访问程序自身的值和类型信息，因此不需要反射系统</strong>。</p>
<p>Go语言程序中的类型（Type）指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称。例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。</p>
<p>Map、Slice、Chan 属于引用类型，使用起来类似于指针</p>
<p><strong>结构体标签（Struct Tag）</strong></p>
<p>通过 reflect.Type 获取结构体成员信息 reflect.StructField 结构中的 Tag 被称为结构体标签（StructTag）。结构体标签是对结构体字段的额外信息标签。结构体标签（Struct Tag）类似于 <a target="_blank" rel="noopener" href="http://c.biancheng.net/csharp/">C#</a><br>
 中的特性（Attribute）。C# 允许在类、字段、方法等前面添加 Attribute，然后在反射系统中可以获取到这个属性系统。例如：</p>
<p>Tag 在结构体字段后方书写的格式如下：<code>key1:"value1" key2:"value2"</code></p>
<p>key会指定<strong>反射的解析方式</strong>，如下： json(JSON标签) orm(Beego标签)、gorm(GORM标签)、bson(MongoDB标签)、form(表单标签)、binding(表单验证标签)</p>
<p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。</p>
<p>指定映射的字段名。为了做到这一点，我们需要为字段设置<code>mapstructure</code>标签。例如下面使用<code>username</code>代替上例中的<code>name</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Person struct {</span><br><span class="line">  Namestring `mapstructure:"username"`</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="JSON">JSON</h2>
<p>Protocol Buffers (Protobuf) over JSON, particularly in evolving systems: <strong>backward and forward compatibility through field numbering.</strong> Let’s break down why this is so powerful:</p>
<p><strong>The Problem with Unstructured Data and Versioning:</strong></p>
<ul>
<li><strong>JSON’s flexibility is a double-edged sword.</strong> While easy to read and work with, it lacks a strict schema. This means changes to field names or data types can easily break compatibility between clients and servers that were written for different versions of the API.</li>
<li><strong>Versioning headaches.</strong> Teams often resort to complex versioning schemes (e.g., in the URL or headers) to manage compatibility, adding overhead and complexity.</li>
</ul>
<p>Benefit</p>
<ul>
<li><strong>Backward Compatibility:</strong> Older clients, unaware of newer fields (added with higher numbers), will simply ignore them. The data for the fields they do understand is still present and correctly parsed.</li>
<li><strong>Forward Compatibility:</strong> Newer clients can receive messages with fields they don’t yet know about (from older servers). They’ll skip over these unknown fields without issues.</li>
<li><strong>No Versioning Hell:</strong> You often avoid the need for explicit API versioning in your Protobuf services, simplifying development and maintenance.</li>
</ul>
<p>PB常用于后端多个服务通信，尤其适用通信接口于字段多，数据结构复杂，需要充分压缩数据的场景</p>
<p><strong>Serialization:</strong></p>
<ul>
<li><strong>What it is:</strong> The process of converting a data structure (like a Protobuf message, a Python object, etc.) into a stream of bytes or a string representation.</li>
<li><strong>Protobuf and Serialization:</strong> Protobuf’s primary function is efficient serialization! Its <code>.proto</code> definitions define the structure, and Protobuf compilers generate code (in various languages) with methods to</li>
</ul>
<p>JSON(marshal, unmarshal)</p>
<p>控制层返回json字符串数据给前端，前端通过ajax处理将数据展示给用户</p>
<p>Substring 从以连续顺序放置在两个指定索引之间的字符串中取出字符。另一方面， <strong>子序列</strong>可以通过删除中间的一些元素或不删除元素从另一个序列导出，但始终保持原始序列中元素的相对顺序。</p>
<p><code>json.Decoder</code>会一个一个元素进行加载，不会把整个json数组读到内存里面，适用于从数据流中解码多个值。例如http连接与socket连接的读取与写入，或者是文件的读取</p>
<p><code>json.Unmarshal</code>适用于读取已经在内存中的json数据进行解码，例如直接是<code>[]byte</code>的输入</p>
<p>Both JSON and XML can be used to receive data from a web server.</p>
<p>parse to JS object:  const obj = JSON.parse(‘{“name”:“John”, “age”:30, “city”:“New York”}’);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">**Json Marshal：将数据编码成json字符串</span><br><span class="line">jsonstu,err := json.Marshal(stu)</span><br><span class="line">if err!=nil{</span><br><span class="line">        fmt.Println("生成json字符串错误")</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">{"name":"张三","Age":18,"HIgh":true,"class":{"Name":"1班","Grade":3}}**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>JSON、BSON 等格式进行序列化及对象关系映射（Object Relational Mapping，简称 ORM）系统都会用到结构体标签，这些系统使用标签设定字段在处理时应该具备的特殊属性和可能发生的行为。这些信息都是静态的，无须实例化结构体，可以通过反射获取到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Type int `json: "type" id:"100"` //ERror:json后多了个空格,无法解析</span><br><span class="line">{//reflect 获取字段tag</span><br><span class="line">var u User</span><br><span class="line">  t:=reflect.TypeOf(u)</span><br><span class="line">  for i:=0;i&lt;t.NumField();i++{</span><br><span class="line">    sf:=t.Field(i)</span><br><span class="line">    fmt.Println(sf.Tag.Get("json"),",",sf.Tag.Get("bson"))</span><br><span class="line">  }</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Json字符串转User对象的例子，这里主要利用的就是User这个结构体对应的字段Tag，json解析的原理就是通过反射获得每个字段的tag，然后把解析的json对应的值赋给他们。</p>
<p>利用字段Tag不光可以把Json字符串转为结构体对象，还可以把结构体对象转为Json字符串。</p>
<h2 id="Object-orient">Object orient</h2>
<p>Golang 没有类和继承等经典的 OOP 功能，但它确实通过其类型系统和接口的使用支持一些基本的 OOP 概念。 Golang 中的关键 OOP 功能包括：在 Golang 中，方法是与特定类型关联的函数。它们是用接收器定义的</p>
<p>this是指向当前对象的指针(姑且用C里面的指针来看吧)</p>
<p>self是指向当前类的指针</p>
<p><strong>多态</strong></p>
<p>Go 语言提供了另外一种数据类型即<strong>接口，它把所有的具有共性的方法</strong>定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p>
<p><strong>继承(组合实现)</strong></p>
<p>type Human struct{}</p>
<p>type Superman struct{</p>
<p>Human//表示继承Human类的方法</p>
<p>}</p>
<h3 id="interface">interface</h3>
<p>在 Go 中，接口是隐式实现的。如果一个type（在本例中为 PostController）包含接口 (PostControllerInterface) 中定义的所有方法，则认为它实现了该接口。</p>
<p>当您定义一个结构体 (PostController) 时，其方法与接口 (PostControllerInterface) 中的方法签名相匹配，Go 编译器会自动推断该 PostController 结构体实现了 PostControllerInterface。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type A interface {</span><br><span class="line">    Get(k string) interface{}</span><br><span class="line">    Set(k string, v interface{})</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func NewA() A {</span><br><span class="line">    return &amp;a{}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type a struct {</span><br><span class="line">    // ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (a0 *a) Get(k string) interface{} {</span><br><span class="line">    // ...</span><br><span class="line">    return nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (a0 *a) Set(k string, v interface{}) {</span><br><span class="line">    // ...</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="结构体">结构体</h3>
<p>Go 中实现 “构造子工厂” 方法。为了方便通常会为类型定义一个工厂，按惯例，工厂的名字以 new 或 New 开头。假设定义了如下的 File 结构体类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type File struct {</span><br><span class="line">fd      int     // 文件描述符</span><br><span class="line">name    string  // 文件名</span><br><span class="line">}</span><br><span class="line">下面是这个结构体类型对应的工厂方法，它返回一个指向结构体实例的指针：</span><br><span class="line"></span><br><span class="line">func NewFile(fd int, name string) *File {</span><br><span class="line">if fd &lt; 0 {</span><br><span class="line">return nil</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f := NewFile(10, "./test.txt")</span><br><span class="line">在 Go 语言中常常像上面这样在工厂方法里使用初始化来简便的实现构造函数。</span><br></pre></td></tr></table></figure>
<p>如果 File 是一个结构体类型，那么表达式 new(File) 和 &amp;File{} 是等价的。</p>
<h3 id="Receiver-type">Receiver type</h3>
<p>With receiver functions you don’t have to mess around with classes or deal with inheritance. The person type has no knowledge of the receiver function. One advantage of using receiver function is when we couple it with iterfaces. I hope to write about interfaces shortly. In a nutshell, by using interfaces we can use the same receiver function to receive arguments of multiple types.</p>
<p>receiver在其他语言以及go语言里也叫做 <strong>函数签名</strong>（函数签名是最普遍的叫法）</p>
<p>相当于类方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type MyStruct struct {</span><br><span class="line">    x int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (m MyStruct) Set1() {</span><br><span class="line">    m.x = 1</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (m *MyStruct) Set2() {</span><br><span class="line">    m.x = 2</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>go get -u</p>
<p>标志指示 get 更新提供命令行上命名的包的依赖项的模块，以便在可用时使用更新的次要版本或补丁版本。</p>
<h2 id="PKG">PKG</h2>
<p>Go的Web框架大致可以分为这么两类：</p>
<ol>
<li>Router框架</li>
<li>MVC类框架</li>
</ol>
<p>!<a target="_blank" rel="noopener" href="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1f4134d3-a1ff-4102-81c1-0b26b70b10e5/Untitled.png">https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1f4134d3-a1ff-4102-81c1-0b26b70b10e5/Untitled.png</a></p>
<ol>
<li>Controller，与上述类似，服务入口，负责处理路由，参数校验，请求转发。</li>
<li>Logic/Service，逻辑（服务）层，一般是业务逻辑的入口，可以认为从这里开始，所有的请求参数一定是合法的。业务逻辑和业务流程也都在这一层中。常见的设计中会将该层称为 Business Rules。</li>
<li>DAO/Repository，这一层主要负责和数据、存储打交道。将下层存储以更简单的函数、接口形式暴露给 Logic 层来使用。负责数据的持久化工作。</li>
</ol>
<p>每一层都会做好自己的工作，然后用请求当前的上下文构造下一层工作所需要的结构体或其它类型参数，然后调用下一层的函数。在工作完成之后，再把处理结果一层层地传出到入口，如<em>图 5-14所示</em>。</p>
<p>!<a target="_blank" rel="noopener" href="https://chai2010.gitbooks.io/advanced-go-programming-book/content/images/ch6-08-controller-logic-dao.png">https://chai2010.gitbooks.io/advanced-go-programming-book/content/images/ch6-08-controller-logic-dao.png</a></p>
<p>Route框架</p>
<p><strong>httproute使用压缩字典树radix tree</strong></p>
<p>字典树常用来进行字符串检索，例如用给定的字符串序列建立字典树。对于目标字符串，只要从根节点开始深度优先搜索，即可判断出该字符串是否曾经出现过，时间复杂度为<code>O(n)</code><br>
，n可以认为是目标字符串的长度。为什么要这样做？字符串本身不像数值类型可以进行数值比较，两个字符串对比的时间复杂度取决于字符串长度。如果不用字典树来完成上述功能，要对历史字符串进行排序，再利用二分查找之类的算法去搜索，时间复杂度只高不低。可认为字典树是一种空间换时间的典型做法。</p>
<p>Go语言的<code>net/http</code>注册的路径和相应的处理函数都存入了m字段中，我们只要知道处理HTTP请求的时候，会调用<code>Handler</code>接口的<code>ServeHTTP</code>方法，而<code>ServeMux</code>正好实现了<code>Handler</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (mux*ServeMux)ServeHTTP(w ResponseWriter, r*Request) {</span><br><span class="line">//省略一些无关代码</span><br><span class="line"></span><br><span class="line">  h, _:= mux.Handler(r)</span><br><span class="line">  h.ServeHTTP(w, r)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>mux.Handler</code>会获取到我们注册的<code>Index</code>函数，然后执行它，具体<code>mux.Handler</code>的详细实现不再分析了，大家可以自己看下源代码。</p>
<p>现在我们可以总结下<code>net/http</code>包对HTTP请求的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP请求-&gt;ServeHTTP函数-&gt;ServeMux的Handler方法-&gt;Index函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就是整个一条请求处理链，现在我们明白了<code>net/http</code>里对HTTP请求的原理。</p>
<p><code>net/http</code>的默认路径处理HTTP请求的时候，会发现很多不足，比如：</p>
<ol>
<li>不能单独的对请求方法(POST,GET等)注册特定的处理函数</li>
<li>不支持Path变量参数</li>
<li>不能自动对Path进行校准</li>
</ol>
<p>所以我们得自己写一个处理请求的router</p>
<h3 id="中间件">中间件</h3>
<p>非业务的需求都是在http请求处理前做一些事情，并且在响应完成之后做一些事情。我们有没有办法使用一些重构思路把这些公共的非业务功能代码剥离出去呢？回到刚开头的例子，我们需要给我们的<code>helloHandler()</code><br>
增加超时时间统计，我们可以使用一种叫<code>function adapter</code>的方法来对<code>helloHandler()</code><br>
进行包装：</p>
<p>中间件是一种业务无关的，在正常的的业务handler处理前后的，独立的逻辑处理片段，嵌入在 HTTP 的请求和响应之间。它可以获得 <code>Echo#Context</code><br>
 对象用来进行一些特殊的操作， 比如记录每个请求或者统计请求数。</p>
<p>eg. 一个http请求过程来窥视一番。</p>
<p>当你在浏览器中输入一个网址时，它会通过 DNS 解析到目标服务注册的公网IP地址</p>
<p>请求到达目标服务的 web 反向代理服务器 Tengine 之后，经过一定的过滤转发到目标服务A上</p>
<p>服务A通过 RPC框架 Dubbo 请求服务B的结果做中间计算，并且从 Tair 缓存中读取计算因子，计算结果</p>
<p>服务A接着使用 Druid 通过 TDDL 写入计算结果到 MySQL Master 节点然后返回结果</p>
<p>异步过程中 Canal 通过模拟 Binlog 主从复制的原理，迅速将这条 Binlog 消费并下发到消息队列 RocketMQ</p>
<p>服务C通过 RocketMQ 消费到事件之后，通过配置中心 ConfigServer 拉取到的策略进行对应策略的事件处理。</p>
<p>这个过程中我们使用了一系列的中间件来协同各个微服务完成整个流程，如web反向代理服务器 Tengine、RPC框架 Dubbo、缓存 Tair、<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%BF%9E%E6%8E%A5%E6%B1%A0&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1663627873%7D">连接池</a> Driud、数据库代理层 TDDL、Binlog 同步工具 Canal、消息队列 RocketMQ、配置中心 ConfigServer。</p>
<p>中间件可以理解为洋葱穿透。</p>
<p>ZooKeeper是一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&amp;spm=1001.2101.3001.7020">分布式</a>协调服务，它的主要作用是为分布式系统提供一致性服务，提供的功能包括：配置维护、命名服务、分布式同步、组服务等。Kafka的运行依赖ZooKeeper。</p>
<p><em>Apache Flink 是一个框架和分布式处理引擎，用于对无界和有界</em>数据流进行状态计算。Flink 被设计为在<em>所有常见的集群环境中运行，以内存中的速度</em>和<em>任何规模</em>执行计算。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Stan ke</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://stan370.github.io/2022/12/07/Go/">https://stan370.github.io/2022/12/07/Go/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint policy. If reproduced, please indicate source
                    <a href="/about" target="_blank">Stan ke</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">
                                    <span class="chip bg-color">计算机基础</span>
                                </a>
                            
                                <a href="/tags/%E7%BC%96%E7%A8%8B/">
                                    <span class="chip bg-color">编程</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                    </ul>
                    
                    <div id="wechat">
                        <img src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/medias/reward/wechat.JPG" class="reward-img" alt="微信打赏二维码">
                    </div>
                    <div id="alipay">
                        TBD
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2023/10/07/General/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/medias/featureimages/7.jpg" class="responsive-img" alt="CS NOTES">
                        
                        <span class="card-title">CS NOTES</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-10-07
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E7%A8%8B/" class="post-category">
                                    计算机工程
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">
                        <span class="chip bg-color">计算机基础</span>
                    </a>
                    
                    <a href="/tags/%E7%BC%96%E7%A8%8B/">
                        <span class="chip bg-color">编程</span>
                    </a>
                    
                    <a href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">
                        <span class="chip bg-color">网络安全</span>
                    </a>
                    
                    <a href="/tags/web/">
                        <span class="chip bg-color">web</span>
                    </a>
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                        <span class="chip bg-color">计算机网络</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/11/17/GoEco/">
                    <div class="card-image">
                        
                        <img src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/medias/featureimages/go.png" class="responsive-img" alt="Go生态常用库 中间件">
                        
                        <span class="card-title">Go生态常用库 中间件</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-11-17
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E7%A8%8B/" class="post-category">
                                    计算机工程
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">
                        <span class="chip bg-color">计算机基础</span>
                    </a>
                    
                    <a href="/tags/%E7%BC%96%E7%A8%8B/">
                        <span class="chip bg-color">编程</span>
                    </a>
                    
                    <a href="/tags/%E5%BC%80%E6%BA%90/">
                        <span class="chip bg-color">开源</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2025</span>
            
            <a href="/about" target="_blank">Stan ke</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/Stan370/stan370.github.io" target="_blank">Matery</a>
            <br>
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;Total Words:&nbsp;<span
                        class="white-color">293.4k</span>
            <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;Total visits:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;Total visitors:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            <br>
            <!-- Matomo -->
            <script>
                var _paq = window._paq = window._paq || [];
                /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
                _paq.push(['trackPageView']);
                _paq.push(['enableLinkTracking']);
                (function() {
                    var u="https://your-matomo-instance.com/";
                    _paq.push(['setTrackerUrl', u+'matomo.php']);
                    _paq.push(['setSiteId', '1']);
                    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
                    g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
                })();
            </script>
            <!-- End Matomo Code -->
            <!-- Privacy Notice -->
            <div class="privacy-notice" style="font-size: 0.8em; margin-top: 10px;">
                <i class="fas fa-shield-alt"></i> This site uses Matomo for privacy-friendly analytics.
            </div>
            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2019";
                        var startMonth = "6";
                        var startDate = "28";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'en';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
    </div>
</footer>

<div class="progress-bar"></div>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
  <div class="modal-content">
    <div class="search-header">
      <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span  >
      <input
        type="search"
        id="searchInput"
        name="s"
        placeholder="Please enter a search keyword"
        class="search-input"
      />
    </div>
    <div id="searchResult"></div>
  </div>
</div>

<script type="text/javascript">
  document.addEventListener('DOMContentLoaded', function() {
    const elems = document.querySelectorAll('.modal');
    const instances = M.Modal.init(elems, {
        dismissible: true,    // Allow modal to be dismissed by clicking outside
        preventScrolling: false, // Allow scrolling while modal is open
        opacity: 0.5,        // Opacity of modal background
        inDuration: 250,     // Transition in duration
        outDuration: 250,    // Transition out duration
        onOpenStart: function() {
            document.body.style.overflow = 'auto';
        },
        onCloseEnd: function() {
            document.body.style.overflow = 'auto';
        }
    });

    // Get modal instance
    const searchModal = document.getElementById("searchModal");
    const modalInstance = M.Modal.getInstance(searchModal);
    
    // Only open modal when search button is clicked
    document.getElementById("openSearchBtn")?.addEventListener("click", function() {
        modalInstance.open();
        searchInput.focus(); 
    });
    function closeSearchModal() {
        modalInstance.close();
    }

    // Handle clicks outside modal
    document.addEventListener("click", function(event) {
        const modalContent = searchModal.querySelector(".modal-content");
        // Check if click is outside modal content
        if (event.target === searchModal && !modalContent.contains(event.target)) {
            closeSearchModal();
        }
    });

    // Add ESC key to close modal
    document.addEventListener("keydown", function(event) {
        if (event.key === "Escape" && searchModal.classList.contains('open')) {
            closeSearchModal();
        }
    });

    var searchFunc = function (path, search_id, content_id) {
      "use strict";
      function debounce(func, wait) {
        let timeout;
        return function () {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, arguments), wait);
        };
      }
      $.ajax({
        url: path,
        dataType: "json",
        success: function (jsonData) {
          // 获取所有文章数据
          console.log(jsonData);
          var datas = jsonData.map(function (post) {
            return {
              title: post.title,
              content: post.content,
              url: post.url,
            };
          });

          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);

          // 搜索输入监听
          $input.addEventListener(
            "input",
            debounce(function () {
              var str = '<ul class="search-result-list">';
              var keywords = this.value
                .trim()
                .toLowerCase()
                .split(/[\s\-]+/);
              $resultContent.innerHTML = "";
              if (this.value.trim().length <= 0) {
                return;
              }
              // Perform local searching
              datas.forEach(function (data) {
                var isMatch = true;
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content
                  .trim()
                  .replace(/<[^>]+>/g, "")
                  .toLowerCase();
                var data_url =
                  data.url.indexOf("/") === 0 ? data.url : "/" + data.url;
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                console.log(data_title, data_content, data_url);
                if (data_title !== "" && data_content !== "") {
                  for (let i = 0; i < keywords.length; i++) {
                    let keyword = keywords[i];
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);

                    if (index_title < 0 && index_content < 0) {
                      isMatch = false;
                      break; // 直接退出关键词遍历
                    } else {
                      if (index_content < 0) {
                        index_content = 0;
                      }
                      if (i === 0) {
                        first_occur = index_content;
                      }
                    }
                  }
                }

                // Show search results
                if (isMatch) {
                  str += `<li>
                <a href="${data_url}" class="search-result-title">${data_title}</a>`;
                  var content = data.content.trim().replace(/<[^>]+>/g, "");
                  if (first_occur >= 0) {
                    var start = Math.max(0, first_occur - 20);
                    var end = Math.min(content.length, first_occur + 80);
                    var match_content = content.substring(start, end);

                    keywords.forEach(function (keyword) {
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(
                        regS,
                        '<em class="search-keyword">$&</em>'
                      );
                    });

                    str += `<p class="search-result">${match_content}...</p>`;
                  }
                  str += "</li>";
                }
              });

              str += "</ul>";
              $resultContent.innerHTML = str;
            }, 300)
          ); // 设置 300 毫秒延迟
        },
        error: function (xhr, status, error) {
          console.error("Search failed:", error);
          document.getElementById(content_id).innerHTML =
            '<p class="search-error">Search failed to load. Please try again.</p>';
        },
      });
    };

    // 初始化搜索
    searchFunc('/search.json', "searchInput", "searchResult");
  });
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/js/matery.js"></script>

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/others/clicklove.js" async="async"></script>
    <script async src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/"></script>
    

    

    

    

    

    
    <script src="https://cdn.jsdelivr.net/gh/Stan370/stan370.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
