---
title: Bios与操作系统
date: 2024-07-10 19:43:33
categories: 
- 计算机科学
tags:
- 计算机基础
---

操作系统很难定义，[7]但有人称其为“为用户及其应用程序管理计算机资源的软件层”。[8]操作系统包括始终在运行的软件（称为内核），但也可以包含其他软件。[7] [9]可以在计算机上运行的另外两种程序是系统程序（与操作系统相关，但可能不是内核的一部分）和应用程序（所有其他软件）。[9]

操作系统有三个主要目的：[10]

操作系统在不同的应用程序之间分配资源，决定它们何时获得中央处理器(CPU) 时间或内存空间。[10]在现代个人计算机上，用户通常希望同时运行多个应用程序。为了确保一个程序不会独占计算机有限的硬件资源，操作系统会为每个应用程序提供一定比例的资源，无论是时间（CPU）还是空间（内存）。[11] [12]操作系统还必须将应用程序彼此隔离，以保护它们免受另一个应用程序代码的错误和安全漏洞的影响，但要允许不同应用程序之间进行通信。
操作系统提供了一个接口，该接口抽象了访问硬件细节（例如物理内存）的细节，以使程序员的工作更加轻松。 虚拟化还使操作系统能够掩盖有限的硬件资源；例如，虚拟内存可以为程序提供几乎无限内存的错觉，而这超出了计算机的实际内存。[
操作系统提供通用服务，例如用于访问网络和磁盘设备的接口。这使应用程序可以在不同的硬件上运行而无需重写。操作系统中包含的服务各不相同，而这些功能占大多数操作系统代码的绝大部分。

## Bios
BIOS 代表基本输入/输出系统，它是在计算机微处理器上运行的程序，用于在计算机开机时启动计算机。 BIOS 是在操作系统 (OS) 之前加载并在启动过程中执行初始化任务的固件。这些任务包括检查硬盘、RAM 和键盘等系统设备以及加载操作系统。 BIOS 还管理操作系统与打印机、鼠标、键盘和视频适配器等连接设备之间的数据流。

BIOS是个程序，存储在BIOS芯片中，而现在的新式电脑用的基本都是UEFI启动，早期的过渡电脑用的都是EFI启动。其实EFI或UEFI的一部分也是存储在一个芯片中，由于它们在表面形式、基本功能上和BIOS差不多，所以习惯上我们也把存储EFI/UEFI的芯片叫做EFI/UEFI BIOS芯片，EFI/UEFI也叫做EFI/UEFI BIOS，但在实际上它们和BIOS根本是不一样的，所以最好还是把后面的“BIOS”尾巴去掉为好，下面就来具体谈一下BIOS、EFI和UEFI。

!https://pic1.zhimg.com/80/v2-2031780e40860ff89222511597c900b4_720w.webp

BIOS用于计算机硬件自检、CMOS设置、引导操作系统启动、提供硬件I/O、硬件中断等4项主要功能，因此BIOS程序可以分为若干模块，主要有Boot Block引导模块、CMOS设置模块、扩展配置数据（ESCD）模块、DMI收集硬件数据模块，其中引导模块直接负责执行BIOS程序本身入口、计算机基本硬件的检测和初始化，ESCD用于BIOS与OS交换硬件配置数据，DMI则充当了硬件管理工具和系统层之间接口的角色，通过DMI，用户可以直观地获得硬件的任何信息，CMOS设置模块就是实现对硬件信息进行设置，并保存在CMOS中，是除了启动初始化以外BIOS程序最常用的功能。

BIOS本身是汇编语言代码，是在16位实模式下调用INT 13H中断执行的，由于x86-64是一个高度兼容的指令集，也为了迁就BIOS的16位实模式的运行环境，所以即使现在的CPU都已是64位，如果还是在BIOS启动（基本见于09年以前的主板），在开机时仍然都是在16位实模式下执行的。16位实模式直接能访问的内存只有1MB，就算你安了4G、8G或者16G还是32G内存，到了BIOS上一律只先认前1MB。在这1MB内存中，前640K称为基本内存，后面384K内存留给开机必要硬件和各类BIOS本身使用，了解了这些，下面谈一下BIOS启动计算机的具体过程。

当按下电源开关时，电源就开始向主板和其他设备供电，这时电压还不稳定，在早期的南北桥主板上，由主板北桥向CPU发复位信号，对CPU初始化；稳定电压后复位信号便撤掉。而对于现在的单南桥主板，则由CPU自身调整稳定电压达到初始化的目的，当电压稳定后，CPU便在系统BIOS保留的内存地址处执行跳转BIOS起始处指令，开始执行POST自检。

在POST自检中，BIOS只检查系统的必要核心硬件是否有问题，主要是CPU、640K基本内存、显卡是否正常，PS/2键盘控制器、系统时钟是否有错误等等。由于POST检查在显卡初始化以前，因此在这个阶段如发生错误，是无法在屏幕上显示的，不过主板上还有个报警扬声器，而且如果主板的8255外围可编程接口芯片没有损坏的话，POST报警声音一定是会出来的。可以根据报警声的不同大致判断错误所在，一般情况下，一声短“嘀”声基本代表正常启动，不同的错误则是不同的短“嘀”声和长“嘀”声组合。POST自检结束后，BIOS开始调用中断完成各种硬件初始化工作。

EFI，是Extensible Firmware Interface的词头缩写，直译过来就是可扩展固件接口，它是用模块化、高级语言（主要是C语言）构建的一个小型化系统，它和BIOS一样，主要在启动过程中完成硬件初始化，但它是直接利用加载EFI驱动的方式，识别系统硬件并完成硬件初始化，彻底摒弃读各种中断执行。EFI驱动并不是直接面向CPU的代码，而是由EFI字节码编写成，EFI字节码是专用于EFI的虚拟机器指令，需要在EFI驱动运行环境DXE下解释运行，这样EFI既可以实现通配，又提供了良好的兼容。此外，EFI完全是32位或64位，摒弃16位实模式，在EFI中就可以实现处理器的最大寻址，因此可以在任何内存地址存放任何信息。另外，由于EFI的驱动开发非常简单，基于EFI的驱动模型原则上可以使EFI接触到所有硬件功能，在EFI上实现**文件读写，网络浏览**都是完全可能的。i，BIOS上的的CMOS设置程序在EFI上是作为一个个EFI程序来执行的，硬件设置是硬件设置程序、而启动管理则是另一个程序，保存CMOS又是另一个程序，虽然它们在形式的Shell上是在一起的。

EFI在功能上完全等同于一个轻量化的OS（操作系统），但是EFI在制定时就定位到不足以成为专业OS的地位上，首先，它只是一个硬件和操作系统间的一个接口；其次，EFI不提供中断访问机制，EFI必须用轮询的方式检查并解释硬件，较OS下的驱动执行效率较低，最后，EFI只有简单的存储器管理机制，在段保护模式下只将存储器分段，所有程序都可以存取任何一段位置，不提供真实的保护服务。伴随着EFI，一种全新的GUID磁盘分区系统（GPT）被引入支持，传统MBR磁盘只能存在4个主分区，只有在创建主分区不足4个时，可以建立一个扩展分区，再在其上建立被系统识别的逻辑分区，逻辑分区也是有数量的，太多的逻辑分区会严重影响系统启动，MBR硬盘分区最大仅支持2T容量，对于现在的大容量硬盘来说也是浪费。GPT支持任意多的分区，每个分区大小原则上是无限制的，但实际上受到OS的规定限制不能做到无限，不过比MBR的2T限制是非常重要的进步。GPT的分区类型由GUID表唯一指定，基本不可能出现重复，其中的EFI系统分区可以被EFI存取，用来存取部分驱动和应用程序，虽然这原则上会使EFI系统分区变得不安全，但是一般这里放置的都是些“边缘”数据，即使其被破坏，一般也不会造成严重后果，而且也能够简单的恢复回来。

当EFI发展到1.1的时候，英特尔决定把EFI公之于众，于是后续的2.0吸引了众多公司加入，EFI也不再属于英特尔，而是属于了Unified EFI Form的国际组织，EFI在2.0后也遂改称为UEFI，UEFI，其中的EFI和原来是一个意思，U则是Unified（一元化、统一）的缩写，所以UEFI的意思就是“统一的可扩展固件接口”，与前身EFI相比，UEFI主要有以下改进：

首先，UEFI具有完整的**图形驱动**功能，之前的EFI虽然原则上加入了图形驱动，但为了保证EFI和BIOS的良好过渡，EFI多数还是一种类DOS界面（仍然是640*480VGA分辨率），只支持PS/2键盘操作（极少数支持鼠标操作），不支持USB键盘和鼠标。到了UEFI，则是拥有了完整的图形驱动，无论是PS/2还是USB键盘和鼠标，UEFI一律是支持的，而且UEFI在显卡也支持GOP VBIOS的时候，显示的设置界面是显卡高分辨率按640*480或1024*768显示，因此画面虽小但很清楚，但是这样会导致屏幕周围大片留黑，不过鱼和熊掌不可兼得，除非UEFI默认窗口大小也是最高分辨率。

其次，UEFI具有一个独特的功能，安全启动，而EFI是没有安全启动的，安全启动（Secure Boot），实际上通俗的解释是叫做固件验证。开启UEFI的安全启动后，主板会根据TPM芯片（或者CPU内置的TPM）记录的硬件签名对各硬件判断，只有符合认证的硬件驱动才会被加载，而Win8以后的Windows则是在操作系统加载的过程中对硬件驱动继续查签名，符合Windows记录的硬件才能被Windows加载，这在一定程度上降低了启动型程序在操作系统启动前被预加载造成的风险，但是这也会造成系统安装变得垄断。

无论EFI还是UEFI，都必须要有预加载环境、驱动执行环境、驱动程序等必要部分组成，为了支持部分旧设备（如在UEFI下挂载传统MBR硬盘，不支持UEFI启动的显卡在UEFI下仍然支持运行等），还需要一个CSM兼容性支持模块、EFI或UEFI都是仅支持GPT磁盘引导系统的，下面就具体谈一下EFI或UEFI启动计算机的过程。

一般地，预加载环境和驱动执行环境是存储在UEFI（UEFI BIOS）芯片中的，当打开电源开关时，电脑的主要部件都开始有了供电，与BIOS不同的是，UEFI预加载环境首先开始执行，负责CPU和内存（是全部容量）的初始化工作，这里如出现重要问题，电脑即使有报警喇叭也不会响，因为UEFI没有去驱动8255发声，不过预加载环境只检查CPU和内存，如果这两个主要硬件出问题，屏幕没显示可以立即确定，另外一些主板会有提供LED提示，可根据CPU或内存亮灯大致判断故障。

CPU和内存初始化成功后，驱动执行环境（DXE）载入，当DXE载入后，UEFI就具有了枚举并加载UEFI驱动程序的能力，在此阶段，UEFI会枚举搜索各个硬件的UEFI驱动并相继加载，完成硬件初始化工作，这相比BIOS的读中断加载速度会快的多，同样如加载显卡的UEFI驱动成功，电脑也会出现启动画面，硬件驱动全部加载完毕后，最后同BIOS一样，也得去启动操作系统。

在启动操作系统的阶段，同样是根据启动记录的启动顺序，转到相应设备（仅限GPT设备，如果启动传统MBR设备，则需要打开CSM支持）的引导记录，引导操作系统并进入，这里需要注意的是，UEFI在检测到无任何操作系统启动设备时，会直接进入UEFI设置页面，而不是像BIOS那样黑屏显示相关信息。

综上对BIOS和UEFI启动计算机过程的叙述，可以概括为：BIOS先要对CPU初始化，然后跳转到BIOS启动处进行POST自检，此过程如有严重错误，则电脑会用不同的报警声音提醒，接下来采用读中断的方式加载各种硬件，完成硬件初始化后进入操作系统启动过程；而UEFI则是运行预加载环境先直接初始化CPU和内存，CPU和内存若有问题则直接黑屏，其后启动PXE采用枚举方式搜索各种硬件并加载驱动，完成硬件初始化，之后同样进入操作系统启动过程。

此外，BIOS是16位汇编语言程序，只能运行在16位实模式，可访问的内存只有1MB，而UEFI是32位或64位高级语言程序（C语言程序），突破实模式限制，可以达到要求的最大寻址。

**网吧：network booting 无盘系统**

无盘系统在设计时，负载均衡

无盘系统靠着每次复位镜像的操作，每次开机都相当于做了一个系统还原，你qq号啥的都得重新输入，浏览记录啥的也不会保存，甚至一些游戏存档都不会留。流氓软件自然也没了。

为啥更慢呢？为啥LOW帧更低呢？

因为无硬盘，本来硬盘在电脑上，需要访问文件，CPU直接读取就行了。

现在无盘系统变成了CPU访问文件——通过网卡发送请求，远端服务器接受请求-远端服务器发送数据。环节多了，延迟也变高了。自然就更慢了。

可能觉得不到1秒，挺快的啊，但是把1毫秒当做一天来看，本来当天下午就能拿到的数据，现在要等几天，还觉得很快么？这种读取就在一些游戏上能造成细微卡顿。

而且网吧的设备，有多少客户机会给上2.5G网口，大部分都是千兆网口，才100M/S的速度，2.5G最高也就250M/S的速度，而老一点的sata硬盘接口都是460M/S起步，M2接口配合现在的nvme固态，速度都是几千算的。不过这个不算主要原因，毕竟日常使用的时候，硬盘需要瞬间读取几百M的数据的情况并不是很多。主要还是延迟。尤其是几百几千个文件一起的时候，每个文件延迟一点，连起来那就多了。